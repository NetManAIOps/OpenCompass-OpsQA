[
    {
        "question": "关于在Oracle Database 19c及更高版本中回收Flashback日志使用的空间，哪两个是正确的？\nA. 只有在快速恢复区（FRA）存在空间压力时才会回收空间。\nB. 当Flashback日志的保留期降低时，空间总是会自动回收。\nC. 在出现空间压力之前，可能会主动回收空间。\nD. 在出现空间压力之前，空间总是会被主动回收。\nE. 当Flashback日志的保留期降低时，空间可能会自动回收。",
        "answer": "C,E"
    },
    {
        "question": "2、以下哪两个关于服务器生成的警报是正确的？\nA. 无状态警报可以手动清除\nB. 无状态警报在一天后会自动清除。\nC. 有状态警报在一天后会自动从警报历史记录中清除\nD. 无状态警报可以从警报历史记录中手动清除。\nE. 有状态警报必须由DBA清除以解决警报中指出的问题。",
        "answer": "A,D"
    },
    {
        "question": "关于升级Oracle Grid Infrastructure，哪三个是正确的？\nA. 新版本将安装在现有版本相同服务器上的单独Oracle Grid Infrastructure主目录中\nB. 仅能从紧接前一个Oracle Grid Infrastructure版本直接升级\nC. 升级过程将自动安装当前版本Oracle Grid Infrastructure的所有强制补丁\nD. 只有grid用户可以执行升级\nE. 在开始升级之前必须关闭现有的Oracle数据库实例\nF. 可以使用现有的Oracle base。",
        "answer": "A,E,F"
    },
    {
        "question": "关于Oracle数据库实例中的程序全局区（PGA）及其管理，哪两个说法是正确的？\n\nA. PGA AGGREGATE LIMII是任何一个会话PGA大小的硬限制。\nB. 当使用共享服务器时，整个PGA位于系统全局区（SGA）中。\nC. 当使用共享服务器时，私有SQL区（UGA）位于系统全局区（SGA）中。\nD. 排序和哈希连接使用PGA内存。\nE. 当使用专用服务器时，私有SQL区（UGA）位于系统全局区（SGA）中。",
        "answer": "C,D"
    },
    {
        "question": "5、您计划使用XTTS执行跨平台PDB传输，哪两个选项是正确的？\nA. 必须存在PDB的备份，使用带有ro PLATFORM子句的BACKUP命令进行备份\nB. 源PDB可以处于MOUNT或OPEN状态\nC. 源PDB必须处于MOUNT状态\nD. 源PDB不能是应用程序根\nE. 自动转换字节序发生\nF. 源和目标平台必须具有相同的字节序",
        "answer": "A,F"
    },
    {
        "question": "6、在从Oracle Database 19c开始进行静默模式安装时，关于操作系统脚本的自动执行，哪两个选项是正确的？\nA. 安装程序将提示输入root或sudo密码\nB. 静默安装始终自动运行操作脚本。\nC. 响应文件可以指定root或sudo密码\nD. 响应文件必须包含root或sudo密码\nE. 响应文件可以指定sudo程序的路径。",
        "answer": "A,E"
    },
    {
        "question": "7、哪三个操作将向Oracle Restart配置添加资源？\nA. 使用Oracle Database Configuration Assistant（DBCA）创建数据库服务。\nB. 使用CREATE DISKGROUP SQL语句创建磁盘组。\nC. 使用CREATE DATABASE SQL语句创建数据库。\nD. 通过修改SERVICE NAMES参数创建Oracle数据库服务。\nE. 使用ASM Configuration Assistant（ASMCA）创建Oracle Automatic Storage Management（ASM）实例。\nF. 使用DBMS SERVICE CREATE SERVICE创建数据库服务。",
        "answer": "A,B,E"
    },
    {
        "question": "8、如何为本地撤销模式配置CDB？\nA. 在受限模式下打开CDB实例。在CDB$ROOT中，删除UNDO表空间，在每个PDB中执行ALTER DATABASE LOCAL UNDO ON，然后重新启动CDB实例。\nB. 在受限模式下打开CDB实例。在CDB$ROOT中，执行ALTER DATABASE LOCAL UNDO ON，在每个PDB中创建一个UNDO表空间，然后重新启动CDB实例。\nC. 在升级模式下打开CDB实例。在CDB$ROOT中，执行ALTER DATABASE LOCAL UNDO ON，然后重新启动CDB实例。\nD. 在只读模式下打开CDB。在CDB$ROOT中，执行ALTER DATABASE LOCAL UNDO ON，然后将CDB更改为读/写模式。\nE. 在升级模式下打开CDB实例。在每个PDB中，执行ALTER DATABASE LOCAL UNDO ON，创建一个UNDO表空间，然后重新启动CDB实例。",
        "answer": "C"
    },
    {
        "question": "9、PDBS 可以进行哪三种活动？\nA. 将应用 PDB 转换为常规 PDB\nB. 将应用 PDB 转换为应用种子\nC. 将常规 PDB 转换为应用 PDB\nD. 将一个应用容器复制到同一 CDB 中的另一个应用容器中\nE. 将应用种子转换为应用 PDB\nF. 将应用 PDB 转换为应用根\nG. 将一个应用容器复制到不同 CDB 中的另一个应用容器中。",
        "answer": "B,C,E"
    },
    {
        "question": "10、用户抱怨数据库性能差\n您想验证用户会话是否等待了某些类型的I/O活动\n哪个视图显示会话至少等待过一次的所有等待？\nA. V$SESSTAT\nB. V$SESSION WAIT\nC. V$SESSION EVENT\nD. V$SESSION\nE. V$SESSION WAIT CLASS",
        "answer": "C"
    },
    {
        "question": "11、关于RMAN复制备份集，哪两个说法是正确的？\nA.它们可以写入介质\nB.它们只能通过使用BACKUP命令的复制选项来创建\nC.可以使用RMAN CONFIGURE命令在进行备份之前指定复制\nD.它们只能写入磁盘。\nE.它们必须写入介质。",
        "answer": "A,C"
    },
    {
        "question": "\"12、检查以下配置：\n1. CDB1是一个运行在ARCHIVELOG模式下的容器数据库。\n2. CDB1中有多个未提交的事务正在运行。\n3. Redo日志组1和2处于INACTIVE状态。\n4. Redo日志组3是当前组。\n在归档之前，Redo日志组3的所有成员都丢失了。\n检查以下可能的步骤：\n1. SHUTDOWN ABORT\n2. STARTUP NOMOUNT\n3. STARUP MOUNT\n4. ALTER DATABASE MOUNT\n5. RESTORE DATABASE\n6. RECOVER DATABASE NOREDO\n7. RECOVER DATABASE UNTILAVAILABLE\n8. RESTORE ARCHIVELOG ALL\n9. ALTER DATABASE OPEN\n10. ALTER DATABASE OPEN RESETLOGS\n选择正确的最少步骤顺序来恢复数据库。\nA. 1、3、5、6、9\nB. 1、3、5、8、6、10\nC. 1、2、5、7、4、10\nD. 1、3、5、7、10\nE. 1、3、5、6、10\nF. 1、3、5、6、10\"",
        "answer": "D"
    },
    {
        "question": "13、模式所有者错误地截断了一张表，必须恢复数据。哪个Oracle Flashback功能可以用来恢复数据？\nA. FLASHBACK VERSION QUERY\nB. FLASHBACK TABLE\nC. FLASHBACK TRANSACTION\nD. FLASHBACK DATABASE\nE. FLASHBACK DATA ARCHIVE",
        "answer": "D"
    },
    {
        "question": "14、在备份到SBT通道时，您确定压缩的Recovery Manager（RMAN）增量级别0备份的读取阶段是瓶颈\n数据库启用了FORCE LOGGING\n以下哪两个选项可以提高读取性能？\nA. 禁用数据库的FORCE LOGGING\nB. 启用异步磁盘I/O\nC. 增加数据库缓冲区缓存的大小。\nD. 增加RMAN多路复用的级别\nE. 增加磁带I/O缓冲区的大小。",
        "answer": "B,D"
    },
    {
        "question": "15、以下哪两个关于Oracle实例恢复是正确的？\nA. 恢复从当前重做日志组的开头开始。\nB. 恢复从任何活动的重做日志组的开头开始，如果没有其他组是活动的，则从当前日志组的开头开始。\nC. 恢复从由检查点进程（ckpt）在控制文件中记录的最后检查点位置开始。\nD. 恢复从实例故障之前由数据库写入器计算的最后检查点位置开始。\nE. 恢复读取重做，直到重做线程的末尾，然后打开数据库。然后SMON回滚任何死亡事务。\nF. 恢复读取重做，直到重做线程的末尾，然后SMON回滚任何死亡事务，然后打开数据库。",
        "answer": "C,E"
    },
    {
        "question": "16、关于使用RMAN恢复表格，哪三个选项是正确的？\nA. RMAN可以恢复SYSAUX表空间中的表格\nB. RMAN总是使用辅助实例\nC. RMAN可以在DDL操作修改表结构后恢复表格\nD. RMAN可以恢复sys用户拥有的表格\nE. RMAN可以恢复SYSTEM表空间中的表格\nF. RMAN可以在备用数据库中恢复表格\nG. RMAN可以恢复SYSTEM用户拥有的表格。",
        "answer": "B,C,G"
    },
    {
        "question": "17、关于为Oracle容器数据库创建RMAN备份，哪两个说法是正确的？\nA. 可以在连接到cdb$root时创建控制文件备份\nB. 即使RMAN连接到CDB$ROOT，BACKUP TABLESPACE命令也可以备份PDB表空间\nC. 可以在连接到CDB$ROOT时创建在线重做日志备份。\nD. 在连接到PPB时无法创建控制文件备份。\nE. 可以在连接到PDB时创建归档重做日志备份。",
        "answer": "A,B"
    },
    {
        "question": "18、关于在Oracle 19c及更高版本中创建可插拔数据库（PDBS），哪两个说法是正确的？\nA. PDB快照依赖于源PDB的现有存储快照\nB. PDB快照可以是源PDB的完整副本\nC. PDB快照可以是源PDB的稀疏副本\nD. 快照副本PDB不依赖于源PDB的现有存储快照\nE. 快照副本PDB可以是源PDB的完整副本。",
        "answer": "B,C"
    },
    {
        "question": "在哪两种情况下可以使用数据库升级助手？\nA. 当操作系统（OS）需要作为升级的一部分更改时\nB. 当必须按特定顺序升级容器数据库中的多个可插入数据库时\nC. 当硬件平台需要作为升级的一部分更改时\nD. 当升级期间需要进行字符集转换时\nE. 当目标和源数据库位于同一平台时",
        "answer": "B,E"
    },
    {
        "question": "20、以下哪三个选项在Oracle 19c及以后的版本中是正确的？\nA. 可以在可插拔数据库（PDB）级别限制同时进行的数据泵作业\nB. 对具有加密列的表进行普通数据泵导出时，导入时总是加密相同的列\nC. 在可传输表空间操作期间，表空间始终保持读/写模式\nD. 可传输数据泵导入可以使插入的表空间保持读/写模式\nE. 在可传输表空间操作期间，表空间从不保持读/写模式\nF. 可传输数据泵导入可以使插入的表空间保持只读模式。",
        "answer": "A,D,F"
    },
    {
        "question": "21、关于补丁集，哪三个说法是正确的？\nA. 它们仅每季度发布一次\nB. 它们通过Opatch或Opatchauto安装\nC. 安装补丁集不需要基础版本\nD. 它们可以引入新功能\nE. 它们可以在集群软件和数据库中以滚动方式应用\nF. 安装补丁集被认为是升级。",
        "answer": "C,D,F"
    },
    {
        "question": "22、以下哪三个说法是关于不使用恢复管理器（RMAN）进行恢复操作的？\nA. 可以使用SQL*PLUS从内存中恢复丢失的SPFILE。\nB. 可以使用SQL*PLUS重新创建丢失的密码文件。\nC. 可以使用orapwd实用程序手动重新创建丢失的密码文件。\nD. 可以在不执行任何恢复操作的情况下重新创建丢失的索引表空间。\nE. 必须始终手动重新创建丢失的TEMPFILE。\nF. 可以使用SQL*PLUS从警报日志中重新创建丢失的PFILE。",
        "answer": "A,C,D"
    },
    {
        "question": "23、关于优化器统计信息，哪两个说法是正确的？\nA. 如果它们过时了，优化器会忽略它们。\nB. 它们提供有关模式对象的实时数据。\nC. 默认情况下，它们会被维护作业自动收集。\nD. 它们由SQL调优顾问收集。\nE. 它们可以由DBMS_STATS包收集。",
        "answer": "C,E"
    },
    {
        "question": "24、关于解释返回到标准输出的恢复管理器（RMAN）错误堆栈，哪三个是正确的？\nA. 如果RMAN命令失败，输出将仅标识失败的命令。\nB. 如果RMAN命令失败，输出将标识故障发生的通道ID。\nC. 媒体管理错误显示为带有“ sbtio”的行。\nD. 错误堆栈中的某些消息不是错误。\nE. 媒体管理错误显示为带有“附加信息”和数字的行。\nF. 媒体管理错误显示为带有“ sbtio”和数字的行。",
        "answer": "B,D,E"
    },
    {
        "question": "在绩效管理中，哪两个因素可能会降低应用程序扩展到更多用户的能力？\nA.  包含由事务更新的表的范围的数据文件数量\nB.  在事务期间发出多个保存点\nC.  编写不良的SQL\nD.  没有经过良好培训的用户不提交事务\nE.  包含由事务更新的表的表空间数量。",
        "answer": "C,D"
    },
    {
        "question": "以下哪三个关于块媒体恢复是正确的？\nA. 目标数据库必须处于打开状态，以便恢复一个或多个块\nB. 包含被恢复块的数据文件仍然在线\nC. 它无法修复逻辑损坏\nD. 它可以在非损坏块上执行\nE. 被恢复的块不可访问\nF. 要使用它，必须启用Flashback Database。",
        "answer": "B,D,E"
    },
    {
        "question": "27、您发出了以下命令：\nRMAN> BACKUP RECOVERY AREA FORCE\n以下哪三个选项是正确的？\nA. 所有已备份到当前FRA的Oracle恢复文件都会被备份\nB. 所有以前的FRA中尚未备份的文件都会被备份\nC. 所有尚未备份的Oracle恢复文件通常会被备份到FRA\nD. 所有已备份到以前任何FRA的Oracle恢复文件都会被备份\nE. 所有尚未备份的当前快速恢复区（FRA）中的文件都会被备份\nF. 所有已备份到当前FRA的文件都会被备份\nG. 所有已备份到以前任何FRA的文件都会被备份。",
        "answer": "A,C,D"
    },
    {
        "question": "以下哪三个关于自动工作负载仓库（AWR）、自动数据库诊断监视器（ADDM）和可管理性监视器（MMON）后台进程是正确的？\n\nA. AWR快照在ADDM不再需要时必须删除\nB. 默认情况下，MMON每30分钟创建一个AWR快照。\nC. ADDM可以建议扩展缓冲区高速缓存\nD. ADDM可以建议缩小缓冲区高速缓存\nE. 默认情况下，AWR快照在8天后会自动清除\nF. ADDM仅在DBA请求时执行其分析。",
        "answer": "C,D,E"
    },
    {
        "question": "29、在Oracle多租户环境中，关于自动工作负载库（AR）和自动数据库诊断监视器（ADDM），哪三个是正确的？\nA. 可以在CDB$ROOT中创建AWR快照\nB. CDBSROOT SYSAUX表空间中没有存储任何AWR数据\nC. ADDM可以在非根容器中运行\nD. 所有AWR数据都存储在CDBSROOR SYSAUX表空间中\nE. 可以在PDB中创建AWR快照\nF. 可以在连接到任何容器时生成AWR报告。",
        "answer": "A,E,F"
    },
    {
        "question": "30、使用恢复管理器（RMAN）复制数据库的哪四个说法是正确的？\nA. 总是需要连接到辅助实例\nB. 总是需要连接到目标数据库实例\nC. 可以复制目标数据库的子集\nD. 复制的数据库总是创建一个新的DBID\nE. 可以通过辅助数据库实例从目标数据库实例拉取备份集来进行复制\nF. 可以通过目标数据库实例将副本推送到辅助数据库实例来进行复制\nG. 总是需要连接到恢复目录实例\nH. 总是需要备份目标数据库。",
        "answer": "A,C,E,F"
    },
    {
        "question": "31、从Oracle 19c开始，数据库配置助手（DBCA）克隆远程可插拔数据库（PDB）的步骤中，以下哪三个是正确的？\nA. 将克隆的PDB保留在挂载状态\nB. 在本地数据库中从CDBSROOR创建到要克隆的远程系统中的PDB的数据库链接\nC. 在本地数据库中从CDBSROOR创建到要克隆的远程系统中的CDBSROOR的数据库链接\nD. 打开克隆的PDB\nE. 备份克隆的PDB",
        "answer": "B,C,D"
    },
    {
        "question": "32、关于Oracle数据库中使用的字符集，哪两个说法是正确的？\nA. Unicode使得可以使用单一字符集存储来自任何语言的信息\nB. Unicode是使用Database Configuration Assistant（DBCA）创建的Oracle数据库唯一支持的字符集\nC. 单字节字符集比多字节字符集提供更好的性能\nD. 单字节字符集总是使用7位编码方案\nE. 多字节字符集允许比单字节字符集更有效的空间利用\nF. 单字节字符集总是使用8位编码方案。",
        "answer": "A,C"
    },
    {
        "question": "33、以下哪三个关于使用数据库升级助手（DBUA）升级数据库是正确的？\nA. 可以同时升级具有相同ORACLE HOME的多个数据库\nB. 所有可插入数据库都会自动升级作为容器数据库的一部分\nC. DBUA必须从目标Oracle Home启动\nD. DBUA执行预升级信息工具脚本\nE. 升级前必须存在整个数据库备份\nF. 数据库必须以只读模式打开。",
        "answer": "B,C,D"
    },
    {
        "question": "在Oracle多租户环境中使用数据库资源管理器，哪三个说法是正确的？\n\nA. Pdb级别的资源计划可以限制会话PGA内存\nB. 使用Pdb级别的资源计划时，必须有一个Cdb级别的资源计划\nC. Cdb级别的资源计划可以限制会话CPU利用率。\nD. Cdb级别的资源计划可以限制PDB UNDO使用\nE. Pdb级别的资源计划可以限制每个消费者组的未提交UNDO\nF. Cdb级别的资源计划可以限制PDB CPU利用率。",
        "answer": "A,B,F"
    },
    {
        "question": "36、以下哪三个关于FLASHBACK DATABASE功能是正确的？\nA. 它总是生成REDO和UNDO\nB. 目标数据库必须处于ARCHIVELOG模式\nC. FLASHBACK DATABASE仅使用FLASHBACK日志将数据库恢复到所需的闪回时间\nD. FLASHBACK日志在日志切换后进行归档\nE. 可以使用SQL*PLUS对数据库进行闪回\nF. 当为数据库启用闪回时，查询和DML具有相同的闪回日志开销。",
        "answer": "A,B,E"
    },
    {
        "question": "在对Oracle数据库环境进行性能调优时，应该首先调整哪个方面？\n\nA. 日志写入性能\nB. SQL语句\nC. 数据库实例内存管理和大小\nD. 操作系统的整体健康状况\nE. 数据库写入性能",
        "answer": "D"
    },
    {
        "question": "38、关于自动快速部署家庭（Rapid Home Provisioning，RHP），以下哪三个说法是正确的，自从Oracle 18c以来就可用？\nA. 它可以用于部署包括Oracle Restart在内的Grid Infrastructure家庭。\nB. 它是一个Oracle Grid Infrastructure服务。\nC. 它是一个Oracle数据库服务。\nD. 它不能用于部署中间件。\nE. 它不能用于部署应用程序。\nF. 它可以用于部署Oracle数据库家庭。",
        "answer": "A,B,F"
    },
    {
        "question": "39、您想将UNIVERSIRY表空间从一个数据库传输到另一个数据库。\nUNIVERSIRY表空间当前处于读/写状态。\n源和目标平台具有相同的字节序。\n请检查以下步骤列表：\n1. 在源系统上将UNIVERSIRY表空间设置为只读\n2. 使用EXPDP导出UNIVERSIRY表空间元数据\n3. 使用包括DAMAPUMP子句的RMAN命令从源系统创建跨平台备份集\n4. 将跨平台备份集复制到目标系统\n5. 将Data Pump转储集从源系统复制到目标系统\n6. 使用包括PAMAPUMP子句的RMAN命令在目标系统上恢复跨平台备份集\n7. 使用IMPDP导入UNIVERSIRY表空间元数据\n8. 在目标系统上将UNIVERSIRY表空间设置为读/写\n哪些是正确顺序的最少步骤，以传输UNIVERSIRY表空间？\nA. 3,4,6\nB. 1,3,4,6,8\nC. 1,2,3,4,5,6,7,8\nD. 2,3,4,5,6,7",
        "answer": "B"
    },
    {
        "question": "\"40、一个数据库被配置为ARCHIVELOG模式\n存在完整的RMAN备份，但没有进行控制文件备份以进行跟踪\n发生了媒体故障\n在哪两种情况下需要进行不完全恢复？\nA. 在失去所有控制文件的副本后\nB. 在失去sysaux表空间数据文件后\nC. 在失去当前在线重做日志组的所有成员后\nD. 在失去一个非活动在线重做日志组的所有成员后\nE. 在失去正在使用的UNDO表空间后\"",
        "answer": "C,E"
    },
    {
        "question": "41、以下哪三个关于应用程序容器是正确的？\nA. 它可以包含单个应用程序\nB. 它可以包含多个应用程序\nC. 两个应用程序容器可以共享一个应用程序种子PDB\nD. 一个应用程序PDB可以属于多个应用程序容器\nE. 它必须有一个应用程序根PDB\nF. 它必须有一个应用程序种子PDB",
        "answer": "A,B,E"
    },
    {
        "question": "以下哪两个关于使用RMAN默认压缩进行备份集压缩是正确的？\nA. 压缩备份不能定义节大小\nB. 高水位线以下未使用的块会被备份\nC. 二进制压缩会增加备份操作的CPU开销\nD. 压缩备份只能写入介质\nE. 压缩只能针对本地管理表空间进行",
        "answer": "C,E"
    },
    {
        "question": "43、关于自动工作负载存储库（AWR）快照，哪三个说法是正确的？\nA. 它们可以永久保留。\nB. 如果统计信息级别设置为ALL，则会生成它们。\nC. 它们总是手动创建的。\nD. 如果统计信息级别设置为BASIC，则会生成它们。\nE. 它们总是自动生成的。\nF. 如果统计信息级别设置为TYPICAL，则会生成它们。",
        "answer": "A,B,F"
    },
    {
        "question": "关于使用RMAN复制可插拔数据库（PDBS），哪两个选项是正确的？\n\nA. 如果复制PDB，则CDB$ROOT和PDBSSEED会自动复制\nB. 必须使用具有SYSDBA或SYSBKUP权限的用户登录到PDB中才能使用RMAN进行复制\nC. 可以使用同一RMAN DUPLICATE命令复制两个或更多的PDBS\nD. 辅助实例会自动创建，并启用PLUGGABLE DATABASE\nE. 复制PDB时必须复制所有属于该PDB的表空间。",
        "answer": "A,C"
    },
    {
        "question": "哪三种能力需要使用RMAN恢复目录？\nA. 使用REPORT SCHEMA命令列出数据库当前的数据文件和表空间\nB. 使用BACKUP命令的KEEP FOREVER子句\nC. 创建加密备份\nD. 创建关于单个数据库备份的定制报告\nE. 使用REPORT SCHEMA命令列出过去某个时间点的数据库数据文件和表空间\nF. 使用RMAN存储的脚本。",
        "answer": "B,E,F"
    },
    {
        "question": "以下哪两个关于Oracle安全和审计功能是正确的？\n\nA. 只有在应用程序容器中的所有PDB关闭时，才能创建应用程序通用的透明安全数据保护（TSDP）策略。\nB. 统一审计可以自动同步到应用程序容器中的所有应用程序PDB。\nC. 只有在应用程序容器中的所有PDB关闭时，才能创建应用程序通用的OLS策略。\nD. 应用程序根目录中的细粒度审计（FGA）策略在更新时会自动同步到应用程序容器中包含的所有应用程序PDB。\nE. 应用程序通用的TSDP策略始终是容器特定的。",
        "answer": "B,E"
    },
    {
        "question": "50、以下哪个陈述正确描述了SQL调优顾问执行的SQL分析？\nA. 它是优化器提供的一组建议，用于创建新的索引。\nB. 它是优化器提供的一组建议，用于更改访问方法。\nC. 它是优化器为SQL语句收集的辅助信息，以帮助使用更好的连接顺序。\nD. 它是优化器提供的一组建议，用于重构SQL语句以避免次优的执行计划。\nE. 它是优化器为SQL语句收集的辅助信息，以消除估计误差。",
        "answer": "E"
    },
    {
        "question": "51、在Linux上执行Oracle数据库安装的哪三个说法是正确的？\nA. 可以在安装独立服务器的Grid Infrastructure之后进行。\nB. 允许您选择Oracle数据库服务器支持的语言。\nC. 可以使用Oracle预安装RPM来配置Oracle数据库安装所有者、Oracle Inventory组和Oracle管理特权组。\nD. 可以在安装独立服务器的Grid Infrastructure之前进行。\nE. runfixup.sh脚本可以安装缺失的RPMS。\nF. 必须使用Oracle预安装RPM来配置Oracle数据库安装所有者、Oracle Inventory组和Oracle管理特权组。\nG. Oracle数据库管理员必须被授予访问根操作系统帐户的权限来运行根特权脚本。",
        "answer": "A,C,D"
    },
    {
        "question": "以下哪三个选项关于整个数据库备份是正确的？\nA. 只能使用RMAN创建\nB. 是NOARCHIVELOG模式下数据库唯一可能的备份类型\nC. 可以是一致的\nD. 可以由备份集或镜像副本组成\nE. 可能是不一致的\nF. 总是包括所有数据文件、当前控制文件、服务器参数文件和归档重做日志。",
        "answer": "C,D,E"
    },
    {
        "question": "哪三个资源始终在CDB$ROOT和可插入数据库（PDBS）之间共享？\nA. 日志写入进程（LGWR）\nB. 撤销表空间\nC. 临时表空间\nD. CDB$ROOT中的数据字典\nE. 进程监视器进程（PMON）\nF. SYSAUX表空间",
        "answer": "A,D,E"
    },
    {
        "question": "54、关于诊断Oracle数据库故障情况的工具，哪三个是正确的？\nA. 自动诊断存储库（ADR）为每个安装的Oracle产品的每个实例都有一个单独的主目录，并使用它。\nB. ADR命令行实用程序（ADRCI）可以打包事件信息以发送给Oracle支持。\nC. ADR可以将元数据存储在Oracle数据库存储库中。\nD. Flashback命令有助于修复物理错误。\nE. 数据恢复顾问使用ADR。\nF. RMAN可以始终修复损坏的块。",
        "answer": "A,B,E"
    },
    {
        "question": "以下哪三个选项关于使用RESTORE POINT子句的RMAN归档备份是正确的？\n\nA. 如果在恢复归档备份时需要将数据库恢复到一致状态，则会保留归档日志。\nB. SPFILE包含在归档备份中。\nC. 备份的ARCHIVAL属性会覆盖RMAN保留策略。\nD. RMAN永远不会将其视为过时备份。\nE. 可以选择将它们写入快速恢复区（FRA）。\nF. 在进行下一次相同数据库的归档备份之前，所有归档日志都会被保留。\nG. 必须使用恢复目录才能支持创建和使用归档备份。",
        "answer": "A,B,C"
    },
    {
        "question": "以下哪三个选项关于备份控制文件是正确的？\nA. 当使用BACKUP SPFILE命令时，它会被RMAN自动备份\nB. 当进行数据库备份时，它会被RMAN自动备份为包含SQL语句的跟踪文件，用于控制文件重建\nC. 它可以自动备份为二进制副本\nD. 它可以手动备份为二进制副本\nE. 它不能手动备份为二进制副本\nF. 它可以手动备份为包含SQL语句的跟踪文件，用于控制文件重建",
        "answer": "C,D,F"
    },
    {
        "question": "57、您想使用Oracle Universal Installer（OUI）为独立服务器安装Oracle Grid Infrastructure。服务器上不存在现有的Oracle安装。\n以下哪两个是先决条件？\nA. Oracle Inventory组oinstall\nB. 安装Oracle ASMLIB\nC. 拥有此安装的操作系统用户\nD. 名为dba的组\nE. 名为grid的操作系统帐户",
        "answer": "A,C"
    },
    {
        "question": "当RMAN刚刚连接到目标数据库和恢复目录数据库时，在哪两种情况下会发生自动完整重新同步目标数据库控制文件和RMAN恢复目录之间的关系？\n\nA. 当由于比CONTROL FILE RECORD KEEP TIME旧而在目标数据库控制文件中覆盖了归档日志备份或镜像副本的控制文件元数据时\nB. 当由于比CONTROL FILE RECORD KEEP TIME旧而在目标数据库控制文件中覆盖了数据文件备份或镜像副本的控制文件元数据时\nC. 当创建当前控制文件的备份时\nD. 当目标首次注册时\nE. 当向已注册的目标数据库添加新的表空间时",
        "answer": "C,D"
    },
    {
        "question": "59、使用Database Upgrade Assistant升级Oracle数据库时，以下哪三个说法是正确的？\nA. 手动升级后，必须更新TNSNAMES.ORA条目以反映新的ORACLE HOME。\nB. 必须通过运行utlrp.sql脚本启用新的扩展数据类型功能。\nC. 在升级Oracle数据库后，应更新Oracle Application Express配置。\nD. 任何恢复管理器（RMAN）恢复目录必须手动升级。\nE. 必须使用DBMS DST PL/SQL包手动升级时区文件。",
        "answer": "B,C,E"
    },
    {
        "question": "一个容器数据库CDB1包含一个可插拔数据库PDB1，另一个容器数据库称为CDB2。您想将PDB1从CDB1迁移到CDB2，且几乎没有停机时间。需要哪三个条件？\nA. CDB1必须仅处于共享UNDO模式\nB. CDB2必须处于归档日志模式\nC. CDB1必须处于归档日志模式\nD. CDB2必须仅处于共享UNDO模式\nE. CDB1和CDB2必须都处于本地UNDO模式\nF. CDB1和CDB2必须都处于共享UNDO模式。",
        "answer": "B,C,E"
    },
    {
        "question": "61、关于基于RPM的Oracle数据库安装，哪两个说法是正确的？\nA. 它需要一个Unbreakable Linux Network（ULN）订阅\nB. 它使用服务配置脚本作为安装的一部分创建单实例数据库\nC. 它执行仅软件的Oracle数据库安装\nD. 它包括Oracle Preinstallation RPM\nE. 从Oracle Database 18c开始，可以使用单个RPM仅安装单个实例的Oracle数据库服务器。",
        "answer": "C,D"
    },
    {
        "question": "关于使用RMAN将数据库克隆到现有CDB中，哪三个选项是正确的？\nA. 目标和辅助实例密码必须相同。\nB. 一次只能克隆一个PDB。\nC. 可以使用同一命令克隆两个或更多个PDB。\nD. 可以将非CDB克隆到PDB中。\nE. 在克隆PDB时，必须使用具有SYSDBA或SYSBKUP权限的用户登录到CDB$ROOT。\nF. 在克隆非CDB时，必须使用具有SYSDBA或SYSBKUP权限的用户登录到被克隆的非CDB中。",
        "answer": "A,B,E"
    },
    {
        "question": "关于容器数据库（CDB）及其可插入数据库（PDB）中的锁定配置文件，哪两个说法是正确的？\n\nA. 可以在应用程序根中创建PDB锁定配置文件\nB. 可以在常规PDB中创建PDB锁定配置文件\nC. 从基本锁定配置文件创建的锁定配置文件如果基于其的配置文件被修改，则永远不会自动修改\nD. 可以在CDB$ROOT中创建PDB锁定配置文件\nE. 从基本锁定配置文件创建的锁定配置文件如果基于其的配置文件被修改，则总是会自动修改",
        "answer": "A,D"
    },
    {
        "question": "以下哪三个关于Oracle Optimizer是正确的？\nA. 它可以在检测到次优计划后重新优化执行计划\nB. 在为SQL语句生成执行计划时，它考虑WHERE子句中的过滤器\nC. 它只能使用与正在生成计划的SQL语句相关联的SQL计划指令\nD. 在为SQL语句生成执行计划时，它考虑对象统计信息\nE. 它会更新数据字典中过期的对象统计信息\nF. 它遵循所有提示。",
        "answer": "A,B,D"
    },
    {
        "question": "\"65、HR_Root应用程序容器必须支持在应用程序本地PDBS PDB1和PDB2以及远程PDB PDB3共享的表上执行查询。哪三个选项是正确的？\nA. 在远程CDB中，应用程序根目录中必须存在代理PDB\nB. 在远程CDB中必须存在指向本地CDB的数据库链接\nC. 在本地CDB根目录中必须存在指向远程CDB的数据库链接\nD. HR_Root副本必须存在于远程CDB中\nE. 在本地CDB中的应用程序根目录中必须存在代理PDB\nF. PDB3的应用程序根目录副本必须存在于本地CDB中\"",
        "answer": "C,D,E"
    },
    {
        "question": "当一个非常大的数据文件被分成四个部分时，关于RMAN多节备份的哪两个说法是正确的？\n\nA. 每个文件部分必须按顺序处理。\nB. 四个部分必须是镜像副本。\nC. 四个部分可以按顺序创建。\nD. 四个部分可以并行创建。\nE. 四个部分必须包含在备份集中。",
        "answer": "C,D"
    },
    {
        "question": "以下哪三个关于Oracle软件的快速主页配置是正确的？\n\nA. 它只能在安装了Oracle Grid Infrastructure的节点上使用\nB. 它可以用于修补现有的Oracle软件安装\nC. 它可以用于在不干扰活动数据库的情况下部署新的主页。\nD. 它只能用于升级运行在Oracle Restart上的单实例数据库。\nE. 它可以用于创建Oracle主页的模板作为仅Oracle数据库的金图像\nF. 它可以用于在已安装的Oracle主页中创建单实例Oracle数据库。",
        "answer": "B,C,D"
    },
    {
        "question": "关于在Oracle Database 19c及更高版本中使用RMAN恢复目录与可插拔数据库（PDB）目标连接，哪三个说法是正确的？\n\nA. 目标PDB必须在虚拟私有目录中注册\nB. 在为注册在虚拟私有目录中的PDB执行时间点恢复时，必须使用基本目录\nC. 目标PDB必须在基本目录和虚拟私有目录中都注册\nD. 目标PDB必须在基本目录中注册\nE. 基本目录所有者必须授予虚拟私有目录访问一个或多个PDB的元数据\nF. 基本目录必须启用虚拟私有目录使用。",
        "answer": "D,E,F"
    },
    {
        "question": "70、一个数据库被配置为ARCHIVELOG模式\n每天进行完整的RMAN备份，没有备份控制文件的跟踪记录，发生了媒体故障\n在哪两种情况下可以进行完全恢复？\nA. 在丢失最近备份后的归档日志时\nB. 在丢失所有控制文件的副本后\nC. 在丢失SYSTEM表空间后\nD. 在丢失最近备份前的归档日志时\nE. 当任何归档日志从最近备份之前、之后或之间损坏时",
        "answer": "B,C"
    },
    {
        "question": "关于Oracle 18c及更高版本中基于Oracle gold image的安装，哪两个选项是正确的？\n\nA. 不需要设置向导\nB. 可用于单实例和集群配置的Oracle Database的安装和升级\nC. 可用于Oracle Database和Oracle Grid Infrastructure的安装\nD. 使用单个RPM自动提取和安装Oracle Database软件\nE. 只能安装和配置Oracle Database软件。数据库必须单独创建。",
        "answer": "B,C"
    },
    {
        "question": "关于从一个容器数据库中拔出一个应用程序容器并插入到另一个容器数据库中，哪两个是正确的？\nA. 两个容器数据库都需要本地UNDO模式\nB. 在拔出应用程序根之前，必须先拔出应用程序容器中的应用程序PDBS。\nC. 应该先将应用程序容器的应用程序根插入到另一个CDB中，然后再插入其应用程序PDBS。\nD. 从CDB中拔出应用程序根会拔出其所有应用程序PDBS。\nE. 将应用程序根插入到不同的CDB中会插入其所有应用程序PDBS。\nF. 只需要在将应用程序容器拔出的数据库中使用本地UNDO模式。",
        "answer": "B,C"
    },
    {
        "question": "哪三个选项是关于具有SYSBACKUP特权的用户可以或不能执行的操作的真实描述？\nA. 他们可以查看任何用户定义的表的数据。\nB. 他们可以删除任何表空间。\nC. 他们可以创建任何表。\nD. 他们不能删除表空间。\nE. 他们可以查看任何数据字典视图或动态性能视图的数据。\nF. 他们不能创建恢复点。",
        "answer": "B,C,E"
    },
    {
        "question": "使用媒体管理器进行RMAN备份的哪两个说法是正确的？\nA. 创建RMAN代理副本需要媒体管理器。\nB. 媒体管理器总是将RMAN请求的备份写入磁带。\nC. Oracle提供的媒体管理器层（MML）例程支持任何供应商的媒体管理产品。\nD. 创建RMAN镜像副本需要媒体管理器。\nE. 默认情况下，请求代理副本可能导致备份集被创建。",
        "answer": "B,E"
    },
    {
        "question": "一个容器数据库（CDB）包含两个可插拔数据库PDB1和PDB2。在CDB中，LOCAL_UNDO_ENABLED数据库属性设置为FALSE。PDB2的数据文件24被删除，需要进行恢复和恢复。唯一存在的RMAN备份是在连接到CDB$ROOT时使用BACKUP DATABASE命令创建的。哪三个是正确的？\nA. 可以在连接到CDB$ROOT时恢复和恢复数据文件24。\nB. 只能在连接到PDB2时恢复数据文件24。\nC. 只能在连接到PDB2时恢复数据文件24。\nD. 只能在连接到CDB$ROOT时恢复数据文件24。\nE. 可以在连接到PDB2时恢复数据文件24。\nF. 可以在连接到CDB$ROOT时恢复数据文件24。",
        "answer": "A,E,F"
    },
    {
        "question": "76. Oracle Automatic Storage Management（ASM）实例执行以下哪三项任务？\nA. 挂载磁盘组\nB. 管理磁盘组内容的分配单元（AU）\nC. 管理Oracle数据库段的扩展分配\nD. 代表数据库服务器进程从ASM磁盘读取数据文件块作为I/O服务器\nE. 代表数据库写入器进程向ASM磁盘写入数据文件块作为I/O服务器\nF. 管理Oracle ASM文件的空间分配。",
        "answer": "A,D,E,\n"
    },
    {
        "question": "\"8月10日，您实施了增量数据库备份策略，并配置了5天的恢复窗口\n级别0备份于8月10日、17日和24日进行\n级别1差异增量备份在级别0备份之间每天进行\n今天是8月26日\n哪些备份将过时？\nA. 8月24日之前的所有备份\nB. 8月17日之前的所有备份\nC. 8月10日之前的所有备份\nD. 8月22日之前的所有备份\nE. 8月20日之前的所有备份\"",
        "answer": "B"
    },
    {
        "question": "78、关于Oracle Grid Infrastructure for a Standalone Server，哪两个说法是正确的？\nA. 它需要单独安装Oracle Automatic Storage Management（ASM）组件\nB. CSS守护程序从Grid Infrastructure主目录运行\nC. 它可以管理安装它的服务器或其他服务器上的数据库资源。\nD. 它支持卷管理、文件系统和自动重启功能\nE. 必须在安装Oracle数据库软件之前安装它。",
        "answer": "B,D"
    },
    {
        "question": "\"79、HR_Root是一个应用程序容器，安装了HR App应用程序。\n在HR_ROOT中尚未创建应用程序PDBS和应用程序种子。\n必须创建一个应用程序PDB，PDB1，以便HR App应用程序的公共对象对其可访问。\n哪两种方法可以使用？\nA. 创建一个应用程序种子，将其与HR Root同步，然后创建PDB1应用程序PDB\nB. 创建PDB1应用程序PDB并将其与HR ROOT同步\nC. 创建一个应用程序种子，并在其中安装HR APP。\nD. 创建PDB1应用程序PDB并将其与PDBSSEED同步\nE. 创建PPB1应用程序PDB并在其中安装HR App。\"",
        "answer": "A,B"
    },
    {
        "question": "80、关于实例恢复，哪两个说法是正确的？\nA. 如果缺少归档日志，则无法进行实例恢复。\nB. 将FAST START MTTR TARGET设置为较高的值可以通过使日志写入更频繁来减少实例恢复时间，从而减少实例恢复期间所需的I/O次数。\nC. 在数据库打开后自动执行实例恢复；但需要恢复的块在恢复之前不可用。\nD. 将FAST START MTTR TARGET设置为较低的值可以通过更频繁地将脏缓冲区写入磁盘来减少实例恢复时间，从而减少实例恢复期间所需的I/O次数。\nE. 在数据库保持MOUNT状态时自动执行实例恢复，然后打开数据库。\nF. 实例恢复由恢复写入器（RVWR）后台进程执行。",
        "answer": "D,E,F"
    },
    {
        "question": "82、关于RMAN虚拟私有目录（VPCS），哪两个说法是正确的？\nA. 每个VPC都由恢复目录模式所有者拥有。\nB. VPC功能默认启用。\nC. 只能在一个VPC中注册一个目标数据库。\nD. RMAN目录所有者可以授予已注册数据库的访问权限给新的虚拟目录所有者。\nE. RMAN使用Oracle虚拟私有数据库（VPD）来实现VPCS。",
        "answer": "D,E,F"
    },
    {
        "question": "84、关于内存顾问，哪两个说法是正确的？\nA. 如果启用了自动内存管理，共享池顾问和缓冲区高速缓存顾问可用于设置这些单个系统全局区组件的最大大小。\nB. 如果启用了手动共享内存管理，则仅可用共享池顾问和缓冲区高速缓存顾问。\nC. 如果启用了自动共享内存管理，则SGA顾问和PGA顾问始终可用。\nD. 如果启用了自动内存管理，则没有内存顾问可用。\nE. 所有内存顾问都使用自动工作负载存储库中的数据。",
        "answer": "C,E"
    },
    {
        "question": "使用FLASHBACK TABLE的前提条件是哪两个？\nA. 必须在要回滚的表上启用行移动\nB. 在执行回滚之前，表的索引必须设置为不可用\nC. 在执行回滚之前，表的约束必须被禁用。\nD. 必须授予执行回滚操作的用户FLASHBACK ANY TABLE系统特权或FLASHBACK对象特权\nE. 必须授予表所有者FLASHBACK ANY TABLE系统特权或FLASHBACK对象特权。",
        "answer": "A,D"
    },
    {
        "question": "以下哪两个关于只读Oracle home是正确的？\nA. 它包含一个可以分布在多个服务器上的映像\nB. 它是通过执行仅软件的Oracle数据库安装，然后运行roohctl-enable脚本来启用的\nC. 它是通过执行带有数据库创建的Oracle数据库安装，然后运行roohctl-enable脚本来启用的。\nD. 它需要快速主机配置服务。\nE. 它的配置数据和日志文件存储在Oracle home的子目录下。",
        "answer": "A,B"
    },
    {
        "question": "关于在应用程序容器中升级应用程序，哪三个说法是正确的？\n\nA. 可以在连接到cdb$root或PDB$SEED时执行升级\nB. 必须指定应用程序名称和版本号才能升级应用程序\nC. 应用程序升级后，应用程序容器的PDB保持与现有应用程序根同步\nD. 必须在连接到CDB$ROOT时执行升级\nE. 应用程序根自动创建克隆\nF. 应用程序升级后，应用程序容器的PDB会自动与应用程序根克隆同步。",
        "answer": "B,C,E"
    },
    {
        "question": "90、关于SQL性能分析器（SPA），哪两个说法是正确的？\nA. 它提供了对分析任务中所有SQL语句的细粒度分析。\nB. 它为分析任务中每个SQL语句提供了执行前和执行后的统计信息。\nC. 它与SQL访问顾问集成。\nD. SPA会同时运行原本并发运行的SQL语句。\nE. 它预测系统变化对SQL工作负载响应时间的影响。",
        "answer": "B,E"
    },
    {
        "question": "使用恢复管理器（RMAN）镜像副本在不同平台之间传输数据库，以下哪三个说法是正确的？\n\nA. 传输的数据库会自动创建一个新的DBID。\nB. 默认情况下，传输的数据库将使用Oracle管理文件（OMF）。\nC. 数据文件可以在源系统上进行转换。\nD. 可以在不同字节序格式的系统之间传输数据库。\nE. 数据文件可以在目标系统上进行转换。\nF. RMAN会自动转换密码文件。",
        "answer": "B,C,E"
    },
    {
        "question": "93、以下哪三个关于Oracle Restart是正确的？\nA. 您可以使用Server Control (SRVCTL)命令向Oracle Restart配置中添加和删除组件\nB. 它可以管理Oracle数据库实例、Oracle Net监听器和Oracle自动存储管理实例\nC. 它运行于Oracle Grid Infrastructure主目录下\nD. 它在集群和非集群环境中均可使用\nE. 如果您使用sol*plus关闭数据库实例，Oracle Restart会将其解释为数据库故障并尝试重新启动实例\nF. Server Control (SRVCTL)实用程序可用于启动和停止Oracle Restart。",
        "answer": "A,B,C"
    },
    {
        "question": "\"94、存储中的一些归档日志备份已被意外删除。应使用哪两个命令来更新恢复目录中备份的状态，以仅显示缺失的备份？\n\nA. 列出所有归档日志备份\nB. 同步目录\nC. 交叉检查所有归档日志备份\nD. 列出归档日志\nE. 报告过时备份\nF. 列出已过期备份\"",
        "answer": "C,F"
    },
    {
        "question": "95、检查以下配置：\n1. cdb1是一个容器数据库。\n2. 在CDB1中有多个可插入数据库（PDBS）。\n5. 每个PDB都有多个带有引用完整性约束的表。\n6. FLASHBACK DATABASE已开启。\n7. UNDO RETENTION GUARANTEE已启用。\n在所有PDBS中进行了多个不需要的多表更改。使用哪种方法可以使用单个命令撤消更改？\nA. 闪回数据库\nB. 闪回表和事务\nC. 闪回事务\nD. 闪回表\nE. 恢复和恢复数据库",
        "answer": "A"
    },
    {
        "question": "96、您必须将一个非CDB Oracle 11g数据库迁移到CDB，而不需要先对非CDB进行升级。用户定义的对象存储在非CDB中的多个表空间中。您可以使用哪三种方法？\nA. 数据泵可传输表空间\nB. 数据泵完整数据库导出和导入\nC. 数据泵完整可传输数据库\nD. 使用Goldengate进行复制\nE. 将非CDB克隆为PDB\nF. DBMS PDB包",
        "answer": "B,D,E"
    },
    {
        "question": "哪三个动作是数据库升级后必须执行的？\nA. 重置密码以强制区分大小写\nB. 设置表空间警报的阈值值\nC. 升级依赖于Oracle维护的抽象数据类型的用户表\nD. 迁移到统一审计\nE. 从新的Oracle主目录运行补丁命令\nF. 使用新的Oracle主目录更新客户端脚本。",
        "answer": "C,E,F"
    },
    {
        "question": "在单实例、多租户容器数据库（CDB）中，以下哪三个只能在CDB$ROOT中定义或部分定义？\nA. 撤销表空间\nB. 临时表空间\nC. 重做日志\nD. 所有数据字典元数据\nE. 用户定义的PL/SQL包\nF. 控制文件\nG. 强制性的Oracle提供的PL/SQL包。",
        "answer": "C,F,G"
    },
    {
        "question": "以下哪两个关于备份加密是正确的？\n\nA. BACKUP BACKUPSET命令可以加密和解密备份集\nB. 镜像副本可以加密\nC. 可以有选择地为特定表空间启用备份加密\nD. 透明数据加密（TDE）密钥库使用RMAN进行备份\nE. 可以使用特定厂商的媒体管理软件将加密的RMAN备份制作到媒体上\nF. 基于密钥库的加密是RMAN备份加密的默认模式",
        "answer": "C,F"
    },
    {
        "question": "101、您的数据库处于ARCHIVELOG模式，并且您计划使用Flashback Database。哪两个特性或参数管理快速恢复区域中的空间可用性？\nA.备份保留策略\nB.DB_CREATE_ONLINE_LOG_DEST_n参数设置\nC.归档日志删除策略\nD.备份优化策略\nE.使用保证的UNDO保留\nF.DB RECOVERY FILE DEST参数设置。",
        "answer": "A,C"
    },
    {
        "question": "102、哪个操作系统组不需要执行Oracle数据库安装？\nA. OSRACDBA\nB. OSDBA\nC. OSASM\nD. OSKMDBA\nE) OSOPER",
        "answer": "E"
    },
    {
        "question": "关于PDB归档文件，哪两个选项是正确的？\nA. 可以对PDB归档运行DBMS_PDB_CHECK.PLUG_COMPATIBILITY\nB. 它们包含一个PDB清单文件和一个PDB的所有数据文件的未压缩形式\nC. 它们仅包含一个PDB的所有数据文件的未压缩形式\nD. 它们包含一个PDB清单文件和一个PDB的所有数据文件的压缩形式\nE. 必须使用DBMS PDB包创建它们\nF. 它们仅包含一个PDB的所有数据文件的压缩形式。",
        "answer": "A,D"
    },
    {
        "question": "\"104您的CDB有两个常规PDB以及一个包含两个应用程序PDB和一个应用程序SEED的应用程序容器。标准PDB$SEED没有进行任何更改。在CDB中可以分配多少个默认临时表空间？\nA. 八个\nB. 六个\nC. 五个\nD. 三个\nE. 七个\"",
        "answer": "A"
    },
    {
        "question": "\"105 在哪两种情况下需要进行不完全恢复？\n在 CDB 中将 LOCAL_UNDO_ENABLED 属性更改为 false 的两个描述是正确的是什么？（选择两个。）\nA. 更改后，只有具有所需特权的公共用户可以在 CDB&ROOT 中创建撤销表空间。\nB. 任何新的 PDB 和现有的 PDB 都会自动配置为使用 CDB$ROOT 中的默认撤销表空间。\nC. 更改后，CDB$ROOT 中只能存在一个撤销表空间。\nD. 更改后，任何具有所需特权的用户都可以在 PDB 中创建撤销表空间。\nE. 必须在更改之前删除存在于 PDB 中的撤销表空间。\nF. 更改后，每个现有的 PDB 都必须重新打开以使新的撤销模式生效。\"",
        "answer": "A,B"
    },
    {
        "question": "\"106 一个名为CDB1的容器数据库启用了OMF。在CDB1中未配置PDB_FILE_NAME_CONVERT。PDB1在本周早些时候从CDB1中拔出。\n检查以下命令，该命令将在CDB1中执行：\nCREATE PLUGGABLE DATABASE pdb1 USING '/u01/app/oracle/oradata/pdb1.xml' \nSOURCE_FILE_NAME_CONVERT=('/u01/app/oracle/oradata/','/u02/app/oracle/oradata/');\n哪两个选项是正确的？（选择两个。）\nA. PDB1数据文件已经存在于正确的位置。\nB. 在执行该命令之前，必须在CDB1中运行DBMS_PDB.CHECK_PLUG_COMPATIBILITY。\nC. 在执行该命令之前，必须设置PDB_FILE_NAME_CONVERT。\nD. /u01/app/oracle/oradata/pdb1.xml不包含PDB1数据文件的当前位置。\nE. 必须从CDB1中删除PDB1。\"",
        "answer": "A,E"
    },
    {
        "question": "\"107您的SALES_ROOT应用程序容器有两个应用程序PDB。 SALES_APP应用程序在两个PDB中都有一个共同的表FIN.REVENUE。检查此查询及其输出：\n哪两个是正确的？ （选择两个。）\nA.在REVENUE表上的查询中不能使用CONTAINERS子句。\nB.REVENUE表必须是列表分区表。\nC.MAPTABLE表为REVENUE表定义了一个常用列的逻辑分区键。\nD.MAPTABLE表是元数据链接表。\nE.REVENUE表存在容器映射，但未启用。\nF.REVENUE表分区在PDB之间不会自动修剪。\"",
        "answer": "C,F"
    },
    {
        "question": "108. 数据库配置助手（DBCA）在从Oracle 19c开始克隆远程可插拔数据库（PDB）时采取的三个步骤是什么？\nA. 在本地数据库中从CDB$ROOT创建到远程系统中的CDB$ROOT的数据库链接，以进行克隆。\nB. 将克隆的PDB保留在挂载状态。\nC. 打开克隆的PDB。\nD. 备份克隆的PDB。\nE. 在本地数据库中从CDB$ROOT创建到远程系统中要克隆的PDB的数据库链接。",
        "answer": "A,C"
    },
    {
        "question": "以下哪三个关于Oracle可插拔数据库（PDB）是正确的？\n\nA. 只有在两者都是相同的Oracle数据库版本时，PDB才能插入到CDB中。\nB. 从PDB$SEED创建的PDB在加载数据后必须设置为读写。\nC. 非CDB可以转换为PDB。\nD. 从PDB$SEED创建的PDB在加载数据后必须设置为只读。\nE. 通过共享数据文件，一个未插入的PDB可以同时插入多个CDB。\nF. 从容器数据库（CDB）中卸载的PDB可以在不更改任何模式的情况下插入到不同的CDB中。\nG. 可以透明地访问远程CDB中的PDB，从而聚合来自本地和远程PDB的结果。",
        "answer": "C,F,G"
    },
    {
        "question": "以下哪三个关于Oracle Grid Infrastructure for a Standalone Server是正确的？\n\nA. 它包括Oracle Restart和Oracle Automatic Storage Management(ASM)软件。\nB. 它在安装过程中创建一个磁盘组。\nC. 它要求在安装之前预定义操作系统的ORACLE_BASE环境变量。\nD. 它需要Oracle ASMLib来管理Automatic Storage Management(ASM)磁盘。\nE. 它需要Oracle ASM Filter Driver(ASMFD)来管理Automatic Storage Management(ASM)磁盘。\nF. Automatic Storage Management(ASM)要求将操作系统组OSASM和OSDBA分配为其安装所有者的辅助组。",
        "answer": "A,B,F"
    },
    {
        "question": "哪个查询是有效的？\nA. 选择dept_id，join_date，SUM（salary）FROM employees GROUP BY dept_id，join_date;\nB. 选择depe_id，join_date，SUM（salary）FROM employees GROUP BY dept_id：\nC. 选择dept_id，MAX（AVG（salary））FROM employees GROUP BY dept_id;\nD. 选择dept_id，AVG（MAX（salary））FROM employees GROUP BY dapt_id;",
        "answer": "A"
    },
    {
        "question": "关于CREATE TABLE命令，哪三个是正确的？\nA. 它可以包括CREATE...INDEX语句来创建索引以强制执行主键约束。\nB. 表的所有者应该在定义表的表空间上有可用的空间配额。\nC. 它隐式执行提交。\nD. 它隐式回滚任何未决事务。\nE. 用户必须具有CREATE ANY TABLE特权才能创建表。\nF. 表的所有者必须具有UNLIMITED TABLESPACE系统特权。",
        "answer": "A,B,C"
    },
    {
        "question": "“CUSTOMERS”表有一个数据类型为数字的“CUST_CREDT_LIMIT”列。哪两个查询可以成功执行？\nA. SELECT TO_CHAR(NVL(cust_credit_limit * .15,'Not Available')) FROM customers;\nB. SELECT NVL2(cust_credit_limit * .15,'Not AvailabIe') FROM customers;\nC. SELECT NVL(cust_credit_limit * .15, 'Not Available') FROM customers;\nD. SLECT NVL(TO_CHAR(cust_credit_limit * .15),'Not available') from customers;\nE. SELECT NVL2(cust_credit_limit,TO_CHAR(cust_credit_limit * .15),'NOT Available') FROM customers;",
        "answer": "D,E"
    },
    {
        "question": "\"检查产品详细信息表的描述：\n名称 空值 类型\n--------------------------------------------------\nPRODUCT_ID 非空值 数字（2）\nPRODUCT_NAME 非空值 VARCHAR2（25）\nPRODUCT_PRICE 数字（8,2）\nEXPIRY_DATE 日期\n哪两个陈述是正确的？\nA. PRODUCT_ID可以被分配为主键约束。\nB. EXPIRY_DATE不能用于算术表达式。\nC. 如果未分配日期，则EXPIRY_DATE默认包含SYSDATE。\nD. 即使没有存储在其中，PRODUCT_PRICE也可以用于算术表达式。\nE. 如果未分配值，则PRODUCT_PRICE默认包含值零。\nF. PRODUCT_NAME不能包含重复值。\"",
        "answer": "A,D"
    },
    {
        "question": "“CUSTOMERS表具有数据类型为VARCHAR2的CUST_LAST_NAME列。该表有两行，其COST_LAST_MANE值为Anderson和Ausson。哪个查询会产生包含第一行Order和第二行Aus的CUST_LAST_SAME输出？\nA. SELECT REPLACE（REPLACE（cust_last_name，'son'，''），'An'，'O'）FROM customers;\nB. SELECT REPLACE（TRIM（TRALING 'son' FROM cust_last_namE.，'An'，'O'）FROM customers;\nC. SELECT INITCAP（REPLACE（TRIM（'son' FROM cust_last_namE.，'An'，'O'））FROM customers;\nD. SELECT REPLACE（SUBSTR（cust_last_name，-3），'An'，'O'）FROM customers;”",
        "answer": "A"
    },
    {
        "question": "关于索引及其在Oracle数据库中的管理，哪三个陈述是正确的？\nA. INVISIBLE索引在对其基础表执行数据操作语言（DML）时不会被维护。\nB. 索引可以作为CREATE TABLE语句的一部分创建。\nC. DROP INDEX语句总是在删除操作期间防止对表进行更新。\nD. 可以在同一表列上创建唯一和非唯一索引。\nE. 降序索引是一种基于函数的索引。\nF. 如果查询在索引列上进行过滤，则在查询执行期间它将始终被使用。",
        "answer": "B,C,E"
    },
    {
        "question": "关于在表、视图和序列上授予对象权限，哪三个是正确的？\nA. UPDATE 只能在表和视图上授予。\nB. DELETE 可以在表、视图和序列上授予。\nC. REFERENCES 只能在表和视图上授予。\nD. INSERT 可以在表、视图和序列上授予。\nE. SELECT 只能在表和视图上授予。\nF. ALTER 只能在表和序列上授予。",
        "answer": "A,C,F"
    },
    {
        "question": "\"EMPLOYEES表包含数据类型为NUMBER的EMP_ID列和数据类型为DATE的HIRE_DATE列。\n您想要显示在入职六个月后第一个星期一的日期。\n会话中NLS_TERRITORY参数设置为AMERICA，因此星期日是一周的第一天。\n哪个查询可以使用？\nA. SELECT emp_id, NEXT_DAY(ADD_MONTHS(hire_date,6), 'MONDAY') FROM employees;\nB. SELECT emp_id, ADD_MONTHS(hire_date,6), NEXT_DAY('MONDAY') FROM employees;\nC. SELECT emp_id, NEXT_DAY(MONTHS_BETWEEN(hire_date,SYSDATE),6) FROM employees;\nD. SELECT emp_id, NEXT_DAY(ADD_MONTHS(hire_date,6),1) FROM employees;\"",
        "answer": "A"
    },
    {
        "question": "以下哪三个陈述关于Oracle数据库中的视图是正确的？\nA. 当查询包含WHERE子句的视图时，SELECT语句不能包含WHERE子句。\nB. 使用视图插入到表中的行将在删除视图时保留在表中。\nC. 视图只能连接属于同一模式的表。\nD. 视图没有段。\nE. 视图没有对象编号。\nF. 可以创建引用其定义查询中不存在的表的视图。",
        "answer": "B,D"
    },
    {
        "question": "关于Oracle同义词，哪两个陈述是正确的？\nA. 同义词可以有同义词。\nB. 所有私有同义词名称在数据库中必须是唯一的。\nC. 任何用户都可以创建公共同义词。\nD. 可以在包中的对象上创建同义词。\nE. 同义词具有对象编号。",
        "answer": "A,E"
    },
    {
        "question": "关于自连接，哪两个陈述是正确的？\nA. 连接键列必须有索引。\nB. 它可以是左外连接。\nC. 它必须是全外连接。\nD. 它可以是内连接。\nE. 它必须是等值连接。",
        "answer": "B,D"
    },
    {
        "question": "关于在Oracle数据库中删除未使用的列，哪三个陈述是正确的？\nA. 如果使用CASCADE选项，可以删除被另一列引用为外键的主键列。\nB. DROP COLUMN命令可以回滚。\nC. 当包含该列的块下次查询时，未使用的列的空间会自动回收。\nD. 当包含该列的行下次查询时，未使用的列的空间会自动回收。\nE. 分区键列不能被删除。\nF. 设置为UNUSED的列仍然计入每个表的1000列限制。",
        "answer": "A,E"
    },
    {
        "question": "分析以下查询语句：\nSELECT TRUNC (ROUND(156.00,-2),-1) FROM DUAL;\n结果是什么？\nA. 16\nB. 160\nC. 150\nD. 200\nE. 100",
        "answer": "D"
    },
    {
        "question": "\"检查这个SQL语句：\nUPDATE orders o\nSET customer_name =\n(SELECT cust_last_name\nFROM customers\nWHERE customer_id=o.customer_iD. ;\n哪两个是正确的？\nA. 子查询在UPDATE语句执行之前被执行。\nB. ORDERS表中的所有现有行都被更新。\nC. 子查询对ORDERS表中的每个更新行都被执行。\nD. 即使子查询选择多行，UPDATE语句也能成功执行。\nE. 子查询不是相关子查询。\"",
        "answer": "B,C"
    },
    {
        "question": "\"检查PRODUCTS表的描述：\n名称 Null? 类型\n-----------------------------------------------------------------\nPRODUCT_ID NOT NULL NUMBER(2)\nPRODUCT_NANE VARCHAR2(10)\nUNIT_PRICE NUMBER(3)\nSURCHARGE VARCHAR2(2)\nEXPIRY_DATE DATE\nDELIVERY_DATE DATE\n哪三个查询使用有效的表达式？\nA.  SELECT produet_id, unit_pricer, 5 \"Discount\",unit_price+surcharge-discount FROM products;\nB.  SELECT product_id, (unit_price * 0.15 / (4.75 + 552.25)) FROM products;\nC.  SELECT ptoduct_id, (expiry_date - delivery_datE.  * 2 FROM products;\nD.  SPLECT product_id, expiry_date * 2 FROM products;\nE.  SELEGT product_id, unit_price, unit_price + surcharge FROM products;\nF.  SELECT product_id,unit_price || \"Discount\" , unit_price + surcharge - discount FROM products;\"",
        "answer": "B,C,E"
    },
    {
        "question": "\"检查这个部分命令：\nCREATE TABLE cust (\ncust_id NUMBER(2),\ncredit_limit NUMBER(10)\n)\nORGANIZATION EXTERNAL\n为了使这个命令成功执行，需要哪两个子句？\nA. DEFAULT DIRECTORY 子句\nB. REJECT LIMIT 子句\nC. LOCATION 子句\nD. ACCESS PARAMETERS 子句\nE. access driver TYPE 子句\"",
        "answer": "A,D"
    },
    {
        "question": "\"检查这个业务规则：\n每个学生可以参与多个项目，每个项目可以有多个学生。\n您必须设计一个实体关系（ER）模型来进行可选数据存储，并允许以以下格式生成报告：\n学生ID，名字，姓氏，项目ID，项目名称，项目任务。\n哪两个陈述是正确的？\nA. 必须创建一个联合键为STUDENT_ID和PROJECT_ID的关联表，该关联表是链接到STUDENTS和PROJECTS实体的外键。\nB. ER必须在STUDENTS和PROJECTS实体之间具有多对多的关系，必须将其解决为1对多的关系。\nC. PROJECT_ID必须是PROJECTS实体中的主键，并且是STUDENTS实体中的外键。\nD. ER必须在STUDENTS和PROJECTS实体之间具有1对多的关系。\nE. STUDENT_ID必须是STUDENTS实体中的主键，并且是PROJECTS实体中的外键。\"",
        "answer": "A,B"
    },
    {
        "question": "哪两个陈述关于SELECT语句中的WHERE和HAVING子句是正确的？\nA. WHERE子句可以用于将行分组后排除它们。\nB. 只有应用于不同表列时，WHERE和HAVING子句才可以在同一语句中使用。\nC. HAVING子句可以与子查询中的聚合函数一起使用。\nD. 在HAVING子句中使用的聚合函数和列必须在查询的SELECT列表中指定。\nE. WHERE子句可以用于在将行分组之前排除它们。",
        "answer": "C,E"
    },
    {
        "question": "“INVOICE表具有数据类型为NUMBER的QTY_SOLD列和数据类型为DATE的INVOICE_DATE列\nNLS_DATE_FORMAT设置为DD-MON-RR。\n以下哪两个关于查询表达式中涉及这些列的数据类型转换是正确的？\nA. invoice_date > '01-02-2019'：使用隐式转换\nB. qty_sold =' 05549821 '：需要显式转换\nC. CONCAT(qty_sold, invoice_datE. ：需要显式转换\nD. qty_sold BETWEEN '101' AND '110'：使用隐式转换\nE. invoice_date = '15-march-2019'：使用隐式转换”",
        "answer": "D,E"
    },
    {
        "question": "\"PRODUCT_INFORMATION表有一个数据类型为NUMBER(8,2)的UNIT_PRICE列。\n评估以下SQL语句：\nSELECT TO_CHAR(unit_price,'$9,999') FROM Product_intormation;\n关于输出，哪两个陈述是正确的？\nA. UNIT_PRICE列包含值1023.99的行将显示为$1,024。\nB. UNIT_PRICE列包含值1023.99的行将显示为$1,023。\nC. UNIT_PRICE列包含值10235.99的行将显示为$1,0236。\nD. UNIT_PRICE列包含值10235.99的行将显示为$1,023。\nE. UNIT_PRICE列包含值10235.99的行将显示为#####。\"",
        "answer": "A,E"
    },
    {
        "question": "在PROMOTIONS表中，PROMO_BEGTN_DATE列的数据类型为DATE， 默认日期格式为DD-MON-RR。关于包含PROMO_BEGIN_DATE的表达式，哪两个陈述是正确的？\nA. TO_NUMBER(PROMO_BEGIN_DATE - 5)将返回数字\nB. TO_DATE(PROMO_BEGIN_DATE * 5)将返回日期\nC. PROMO_BEGIN_DATE - SYSDATE将返回数字\nD. PROMO_BEGIN_DATE - 5将返回日期\nE. PROMO_BEGIN_DATE - SYSDATE将返回错误。",
        "answer": "C,D"
    },
    {
        "question": "关于Oracle数据库中的事务，哪两个陈述是正确的？\nA. 如果用户退出SQL*Plus，则未提交的事务会自动提交。\nB. 数据操作语言（DML）语句总是开始一个新的事务。\nC. 用户始终可以在不同会话中看到同一用户进行的未提交更新。\nD. 数据定义语言（DDL）语句仅对由DDL引起的数据字典更新自动提交。\nE. 会话始终可以看到自己进行的未提交更新。\nF. 如果会话有未提交的事务，则DDL语句在开始新事务之前会发出COMMIT。",
        "answer": "A,E"
    },
    {
        "question": "\"检查PRODUCTS表的描述：\n名称 NULL? 类型\n------------------------------------------------------------------------\nPROD_ID NOT NULL VARCHAR2(6)\nQUANTITY NUMBER(8,2)\nPRICE NUMBER(10.2)\nEXPIRY_DATE DATE\n该表中存在所有列的数据。您将PRODUCTS表设置为只读模式。\n哪三个命令可以在PRODUCTS上成功执行？\nA. ALTER TABLE products DROP COLUMN expiry_date;\nB. CREATE INDEX price_idx on products (price);\nC. ALTER TABLE products SET UNUSED(expiry_date);\nD. TRUNCATE TABLE products;\nE. ALTER TABLE products DROP UNUSED COLUMNS;\nF. DROP TABLE products。\"",
        "answer": "B,E,F"
    },
    {
        "question": "以下哪三个陈述关于全局临时表是正确的？\nA. 全局临时表不能有公共同义词。\nB. 全局临时表可以有多个索引。\nC. 全局临时表可以在视图的定义查询中引用。\nD. 对全局临时表进行数据操作语言（DML）不会生成重做。\nE. 全局临时表只能有一个索引。\nF. 可以在全局临时表上创建触发器。",
        "answer": "B,C,D"
    },
    {
        "question": "以下哪三个陈述关于在关系型数据库中定义表之间的关系是正确的？\nA. 外键列允许空值。\nB. 唯一键列允许空值。\nC. 主键列允许空值。\nD. 每个主键或唯一键值必须引用一个匹配的外键值。\nE. 每个外键值必须引用一个匹配的主键或唯一键值。",
        "answer": "A,B,E"
    },
    {
        "question": "\"你只能通过系统权限执行哪三个操作？\nA. 在另一个模式中截断表。\nB. 通过数据库访问存储在操作系统目录中的平面文件。\nC. 登录到数据库。\nD. 查询数据库中的任何表。\nE. 使用WITH GRANT OPTION子句。\nF. 在另一个模式中执行过程。\"",
        "answer": "C,D,F"
    },
    {
        "question": "关于DUAL表，哪两个陈述是正确的？\nA. 它可以显示多行和多列。\nB. 只有SYS用户可以访问它。\nC. 任何在任何模式中具有SELECT权限的用户都可以访问它。\nD. 它可以显示多行，但只有单个列。\nE. 它由一个VARCHAR2数据类型的单行和单列组成。\nF. 它只能用于显示常量或伪列。",
        "answer": "A,C"
    },
    {
        "question": "“ORDERS表有一个日期类型为DATE的ORDER_DATE列，默认显示格式为DD-MON-RR。哪两个WHERE条件展示了转换函数的正确使用？\nA. WHERE ordet_date > TO_CRAR(ADD_MONTHS(SYSDATE, 6), 'MON DD YYYY')\nB. WHERE TO_CHAR(order_date, 'MON DD YYYY') = 'JAN 20 2019'\nC. WHERE order_date > TO_DATE('JUL 10 2018', 'MON DD YYYY')\nD. WHERE order_date IN (TO_DATE ('Oct 21 2018', 'MON DD YYYY'), TO_CHAR('Nov 21 2018','MON \nDD YYYY'))\nE. WHERE order_date > TO_DATE(ADD_MONTHS(SYSDATE,6),'MON DD YYYY')”",
        "answer": "B,C"
    },
    {
        "question": "\"选择两个。\n· MANAGER 是一个没有特权或角色的现有角色。\n· EMP 是一个包含 CREATE TABLE 权限的现有角色。\n· EMPLOYEES 是 HR 模式中的一个现有表。\n哪两个命令可以成功执行？\nA. GRANT CREATE SEQUENCE TO manager, emp;\nB. GRANT SELECT，INSERT ON hr.employees TO manager WITH GRANT OPTION：\nC. GRANT CREATE TABLE，emp TO manager;\nD. GRANT CREATE TABLE，SELECT ON hr.employees TO manager;\nE. GRANT CREATE ANY SESSION，CREATE ANY TABLE TO manager;\"",
        "answer": "A,C"
    },
    {
        "question": "\"评估这些成功执行的命令\nCREATE SEQUENCE ord_seq\nINCREMENT BY 1\nSTART WITH 1\nMAXVALUE 100000\nCYCLE\nCACHE 5000;\n关于ORD_ITEMS表和ORD_SEQ序列，哪两个语句是正确的？\nA. 任何插入ORD_ITEMS表的用户必须被授予对ORD_SEQ序列的访问权限。\nB. 当插入ORD_ITEMS时，如果没有为ORD_NO指定显式值，则从序列ORD_SEQ获取下一个数字。\nC. 序列ORD_SEQ在每5000个数字后循环回1，并且可以循环20次。\nD. 如果删除序列ORD_SEQ，则插入ORD_ITEMS的行的ORD_NO列的默认值将为NULL。\nE. 序列ORD_SEQ保证不会生成重复的数字。\"",
        "answer": "A,B"
    },
    {
        "question": "\"检查CUSTOMERS表中CUST NAME列中的数据：\nCUST_NAME\n------------------------------\nRenske Ladwig\nJason Mallin\nSamuel McCain\nAllan MCEwen\nIrene Mikkilineni\nJulia Nayer\n您想显示姓氏以Mc或MC开头的CUST_NAME值。\n哪两个WHERE子句可以得到所需的结果？\nA. WHERE INITCAP(SUBSTR(cust_name, INSTR(cust_name,' ') +1 ) ) IN ('MC%', 'Mc%)\nB. WHERE UPPER(SUBSTR(cust_nane, INSTR(cust_name, ' ') +1 ) ) LIKE UPPER('MC%')\nC. WHERE INITCAP(SUBSTR(cust_nane, INSTR(cust_name,' ') +1 ) ) LIKE 'Mc%'\nD. WHERE SUBSTR(cust_name,INSTR(cust_name,' ') +1 ) LIKE 'Mc%' OR 'MC%'\nE. WHERE SUBSTR(cust_name, INSTR(cust_name,' ') +1 ) LIKE 'Mc%'\"",
        "answer": "B,C"
    },
    {
        "question": "\"检查这个SQL语句：\nSELECT cust_id, cus_last_name \"Last Name\"\nFROM customers\nWHERE country_id = 10\nUNION\nSELECT cust_id CUST_NO, cust_last_name\nFROM customers\nWHERE country_id = 30\n识别三个ORDER BY子句，其中任何一个都可以成功完成查询。\nA. ORDER BY 2, 1\nB. ORDER BY \"CUST_NO\"\nC. ORDER BY 2，cust_id\nD. ORDER BY CUST_NO\nE. ORDER BY \"Last Name\"\"\n",
        "answer": "A,C,E"
    },
    {
        "question": "以下哪三个陈述关于自连接是正确的？\nA. 它必须是内连接。\nB. 它可以是外连接。\nC. 必须使用ON子句。\nD. 它必须是等值连接。\nE. 查询必须使用两个不同的表别名。\nF. 可以使用ON子句。",
        "answer": "B,C,D"
    },
    {
        "question": "使用INTERSECT运算符在复合查询中的结果中哪两个陈述是正确的？\nA. 反转交叉表的顺序有时会影响输出。\nB. 复合查询中每个SELECT中的列名可以不同。\nC. INTERSECT返回复合查询两侧共同的行。\nD. 复合查询中每个SELECT中的列数可以不同。\nE. INTERSECT忽略NULL值。",
        "answer": "B,C"
    },
    {
        "question": "关于COUNT函数，哪两个陈述是正确的？\n\nA. 它只能用于NUMBER数据类型。\nB. COUNT(DISTINCT inv_amt)返回不包含INV_AMT列中重复和NULL行的行数。\nC. COUNT(*)返回表中的行数，包括重复行和任何列中包含NULL的行。\nD. 使用DISTINCT关键字的COUNT函数的SELECT语句不能有WHERE子句。\nE. COUNT(inv_amt)返回表中包括INV_AMT列中NULL行的行数。",
        "answer": "B,C"
    },
    {
        "question": "关于单个实例的Oracle数据库中的序列，哪三个陈述是正确的？\nA. 如果实例关闭，序列的未分配缓存值将丢失。\nB. 两个或多个表不能使用相同的序列生成键。\nC. 如果事务失败，分配的序列号可以回滚。\nD. 序列可以发出重复的值。\nE. 序列总是可能存在间隔。\nF. 只有DBA才能删除序列。",
        "answer": "A,D,E"
    },
    {
        "question": "\"检查PRODUCT_INFORMATION表的描述：\n名称 NULL？类型\n------------------------------------------------------------------------\nPROD_ID NOT NULL NUMBER(2)\nPROD_NANE VARCRAR2 (10)\nLIST_PRICE NUMBER(6,2)\n哪个查询检索具有空列表价格的产品数量？\nA. 从Product_intormation中选择（COUNT（list_pricE）。其中list_price=NULL;\nB. 从pruduct_information中选择Count（nvl（list_price，0））WHERE list_price is null;\nC. 从produet_infomation中选择COUNT（DISTINCT last_pricE）。其中last_price为nulll。\nD. 从proceduct_information中选择COUNT（list_pricE）。其中list_price为NULL; \"",
        "answer": "B"
    },
    {
        "question": "\"您需要计算从2019年1月1日到今天的天数。\n日期以默认的DD-MON-RR格式存储。\n哪两个查询可以给出所需的输出？\nA. SELECT SYSDATE - TO_DATE('01-JANUARY-2019') FROM DUAL;\nB. SELECT TO_DATE(SYSDATE, 'DD/MONTH/YYYY') - '01/JANUARY/2019' FROM DUAL;\nC. SELECT ROUND(SYSDATE - TO_DATE('01/JANUARY/2019')) FROM DUAL;\nD. SELECT TO_CHAR(SYSDATE, 'DD-MON-YYYY') - '01-JAN-2019' FROM DUAL;\nE. SELECT ROUND(SYSDATE - '01-JAN-2019') FROM DUAL:\"",
        "answer": "A,C"
    },
    {
        "question": "\"检查BOOKS_TRANSACTIONS表的描述：\n名称 Null? 类型\n----------------------------------------------------------------------------------------------\nTHANSACTION_ID NOT NULL VARCHAR2(6)\nTRANSACTION_TYPE VARCHAR2(3)\nBORROWED_DATE DATE\nBOOK_ID VARCHAR2(6)\nMEMBER_ID VARCHAR2(6)\n\n检查这个部分的SQL语句：\nSELECT * FROM books_transctions;\n\n哪两个WHERE条件会得到相同的结果？\nA. WHERE borrowed_date = SYSDATE AND (transaction_type= 'RM' OR member_id IN \n('A101','A102' ) );\nB. WHERE borrowed_date = SYSDATE AND transaction_type= 'RM' OR member_id IN \n('A101','A102' ) ;\nC. WHERE borrowed_date = SYSDATE AND (transaction_type= 'RM' AND member_id='A101' OR \nmember_id = 'A102') );\nD. WHERE (borrowed_date = SYSDATE AND transaction_type= 'RM' ) OR member_id IN \n('A101','A102' );\nE. WHERE borrowed_date = SYSDATE AND (transaction_type= 'RM' AND ( member_id= 'A101' OR \nmember_id = 'A102' ) );\"",
        "answer": "B,D"
    },
    {
        "question": "关于单行函数，哪两个陈述是正确的？\nA. CONCAT：可用于组合任意数量的值\nB. MOD：返回除法操作的商\nC. CEIL：可用于正数和负数\nD. FLOOR：返回大于或等于指定数字的最小整数\nE. TRUNC：可用于数字和日期值。",
        "answer": "C,E"
    },
    {
        "question": "“ORDERS表在ORDER_ID列上有一个主键约束。\nORDER_ITEMS表在ORDER_ID列上有一个外键约束，引用ORDERS表的主键。\n该约束定义为ON DELETE CASCADE。\nORDERS表中有ORDER_TOTAL小于1000的行。\n哪三个DELETE语句可以成功执行？\nA. DELETE FROM orders WHERE order_total<1000;\nB. DELETE * FROM orders WHERE order_total<1000;\nC. DELETE orders WHERE order_total<1000;\nD. DELETE FROM orders;\nE. DELETE order_id FROM orders WHERE order_total<1000;”",
        "answer": "A,C,D"
    },
    {
        "question": "\"检查这个SQL语句：\nDELETE FROM employees e\nWHERE EXISTS\n(SELECT 'dummy'\nFROM emp_history\nWHERE employee_id = E.employee_iD. \n哪两个是正确的？\nA. 子查询针对EMPLOYEES表中的每一行都会执行。\nB. 子查询不是相关子查询。\nC. 在执行DELETE语句之前，子查询会被执行。\nD. EMPLOYEEE表中的所有现有行都将被删除。\nE. 即使子查询选择多行，DELETE语句也会成功执行。\"",
        "answer": "A,E"
    },
    {
        "question": "你执行了这个命令：\nTRUNCATE TABLE depts;\n哪两个是正确的？\nA. 它会删除在表上定义的任何触发器。\nB. 它会保留在表上定义的索引。\nC. 它会保留在表上定义的完整性约束。\nD. 可以使用ROLLBACK语句检索已删除的数据。\nE. 它总是保留已删除行使用的空间。\nF. 可以使用FLASHBACK TABLE语句检索已删除的数据。",
        "answer": "B,C"
    },
    {
        "question": "销售表格具有数据类型为NUMBER的PROD_ID和QUANTITY_SOLD列。哪两个查询语句可以成功执行？\nA. 选择COUNT(prod_id) FROM sales WHERE quantity_sold>55000 GROUP BY prod_id;\nB. 选择prod_id FROM sales WHERE quantity_sold > 55000 GROUP BY prod_id HAVING \nCOUNT(*) > 10;\nC. 选择COUNT(prod_id) FROM sales GROUP BY prod_id WHERE quantity_sold > 55000;\nD. 选择prod_id FROM sales WHERE quantity_sold> 55000 AND COUNT(*) > 10 GROUP BY \nCOUNT(*) > 10;\nE. 选择prod_id FROM sales WHERE quantity_sold> 55000 AND COUNT(*) > 10 GROUP BY \nprod_id HAVING COUNT(*) > 10;",
        "answer": "A,B"
    },
    {
        "question": "你被委托为银行应用程序创建一个表格。\n其中一列必须满足三个要求：\n1）以支持日期算术的格式存储，而不使用转换函数\n2）存储长达10年的贷款期限\n3）用于计算贷款未偿还天数的利息\n你应该使用哪种数据类型？\nA. TIMESTAMP WITH TIMEZONE\nB. TIMESTAMP\nC. TIMESTAMP WITH LOCAL TIMEZONE\nD. INTERVAL YEAR TO MONTH\nE. INTERVAL DAY TO SECOND",
        "answer": "E"
    },
    {
        "question": "关于从表中删除列，哪三个是正确的？\nA. 只有当列不包含数据时才能删除列。\nB. 列删除隐含地提交。\nC. 在任何其他表中被另一列引用的列不能被删除。\nD. 必须将列设置为未使用状态，然后才能从表中删除。\nE. 主键列不能被删除。\nF. 可以使用ALTER TABLE命令同时删除多个列。",
        "answer": "B,C,F"
    },
    {
        "question": "哪三个陈述关于全局临时表是正确的？\nA. 对全局临时表的DELETE命令无法回滚\nB. 由会话插入的全局临时表行对任何其他已被授予表选择权限的会话都可用\nC. 会话终止时存在的任何全局临时表行都将被删除\nD. 全局临时表的定义可用于多个会话；\nE. 全局临时表的空间分配发生在会话开始时。\nF. 在会话中发出的TRUNCATE命令会导致删除发出会话中全局临时表中的所有行。",
        "answer": "C,D,F"
    },
    {
        "question": "\"使用以下命令创建表格：\nCREATE TABLE rate_list (rate NUMBER(6,2));\n执行语句时哪两个选项是正确的？\nA. INSERT INTO rate_list VALUES (-.9) 将值插入为 -.9。\nB. INSERT INTO rate_list VALUES (0.999) 会产生错误。\nC. INSERT INTO rate_list VALUES (-10) 会产生错误。\nD. INSERT INTO rate_list VALUES (87654. 556) 将值插入为 87654.6。\nE. INSERT INTO rate_list VALUES (0.551) 将值插入为 .55。\nF. INSERT INTO rate_list VALUES (-99.99) 将值插入为 99.99。\"",
        "answer": "A,E"
    },
    {
        "question": "关于非等值连接语句的性能，以下哪个说法是正确的？\nA. Orade连接语法的性能优于符合SQL:1999标准的ANSI连接语法。\nB. 表别名可以提高性能。\nC. BETWEEN条件总是比使用>=和<=条件性能差。\nD. 使用的连接语法对性能没有影响。\nE. BETWEEN条件总是比使用>=和<=条件性能更好。",
        "answer": "A,B"
    },
    {
        "question": "在NLS_DATE_FORMAT设置为DD-MON-YYYY SH24:MI:SS的会话中，哪两个陈述是正确的？\nA. 只有在默认日期格式为DD-MON-RR时，才可以在表达式中使用SYSDATE。\nB. CURRENT_TIMESTAMP返回与CURRENT_DATE相同的日期。\nC. CURRENT_DATE根据会话时区返回当前日期和时间。\nD. SYSDATE和CURRENT_DATE返回设置为数据库服务器操作系统的当前日期和时间。\nE. CURRENT_TIMESTAMP返回与SYSDATE相同的日期和时间，还有额外的功能秒数细节。\nF. 只能从DUAL表中查询SYSDATE。",
        "answer": "C,D"
    },
    {
        "question": "哪两个陈述关于条件插入（conditional INSERT ALL）是正确的？\nA. 子查询返回的每一行只能插入到一个目标表中。\nB. 它不能有ELSE子句。\nC. 插入的总行数始终等于子查询返回的行数。\nD. 单个WHEN条件可以用于多个INTO子句。\nE. 每个WHEN条件都会针对子查询返回的每一行进行测试。",
        "answer": "D,E"
    },
    {
        "question": "关于INTERVAL数据类型，哪两个陈述是正确的？\n\nA. INTERVAL YEAR TO MONTH列仅支持年份范围内的月份间隔。\nB. INTERVAL DAY TO SECOND列中的值可以复制到INTERVAL YEAR TO MONTH列中。\nC. INTERVAL YEAR TO MONTH列仅支持单年内的月份间隔。\nD. INTERVAL YEAR TO MONTH列中的YEAR字段必须是正值。\nE. INTERVAL DAY TO SECOND列支持秒的小数部分。\nF. INTERVAL YEAR TO MONTH列支持年份间隔。\n\n正确答案：C和E。",
        "answer": "E,F"
    },
    {
        "question": "关于使用SET操作（如UNION）的SQL语句，以下哪两个说法是正确的？\n\nA. 第二个查询返回的每个列的数据类型必须可以隐式转换为第一个查询返回的相应列的数据类型。\nB. 第二个查询返回的每个列的数据类型必须与第一个查询返回的相应列的数据类型完全匹配。\nC. 查询中所有SELECT语句的列数必须相同，但列名可以不同。\nD. 第二个查询返回的每个列的数据类型组必须与第一个查询返回的相应列的数据类型组匹配。\nE. 查询中所有SELECT语句的列名和数量必须相同。",
        "answer": "A,C"
    },
    {
        "question": "\"检查这个查询：\nSELECT 2 FROM dual d1 CROSS JOIN dual d2 CROSS JOIN dual d3;\n执行后返回什么？\nA. 0行\nB. 错误\nC. 8行\nD. 6行\nE. 1行\nF. 3行\"",
        "answer": "E"
    },
    {
        "question": "\"检查以下查询语句：\nSELECT employee_id,first_name,salary\nFROM employees\nWHERE hire_date > '&1';\n当执行此查询时，应使用哪两种方法来防止提示输入雇佣日期值？\nA. 在执行查询之前使用DEFINE命令。\nB. 将查询存储在脚本中，并在执行脚本时传递替换值。\nC. 在查询中将'&1'替换为'&&1'。\nD. 在执行查询之前执行SET VERIFY OFF命令。\nE. 在执行查询之前使用UNDEFINE命令。\nF. 在执行查询之前执行SET VERIFY ON命令。\"",
        "answer": "A,C"
    },
    {
        "question": "\"选择最佳答案\n检查CUSTOMERS表的描述：\n名称 空？ 类型\n-----------------------------------------------------------------------------------------\nCUST_ID Not NULL VARCHAR2(6)\nFIRST_NAME VARCHAR2(50)\nLAST_NAME Not NULL VARCHAR2(50)\nADDRRESS VARCHAR2(50)\nCITY VARCHAR2(25)\n您想显示所有居住在以字母D开头且至少有两个字符的城市中的客户的详细信息\n哪个查询可以使用？\nA. SELECT * FROM customers WHERE city = 'D_%';\nB. SELECT * FROM customers WHERE city = '%D_';\nC. SELECT * FROM customers WHERE city LIKE 'D_ _%';\nD. SELECT * FROM customers WHERE city LIKE 'D_';\"",
        "answer": "C"
    },
    {
        "question": "检查BOOKS表的描述：\n名称 空？ 类型\n-------------------------------------------------- -----------\nTRANSACTION_ID NOT NULL VARCHAR2（6）\nTRANSACTION_DATE DATE\nAMOUNT NUMBER（10,2）\nCUSTOMER_ID VARCHAR2（6）\n该表有100行\n检查在新会话中发出的语句序列：\nINSERT INTO books VALUES（'ADV12'，'汤姆·索亚历险记'，NULL，NULL）;\nSAVEPOINT a;\nDELETE FROM books;\nROLLBACK TO SAVEPOINT a;\nROLLBACK;\n哪两个语句是正确的？\nA.第一个ROLLBACK命令恢复了被删除的101行并提交了插入的行。\nB.第一个ROLLBACK命令恢复了被删除的101行，留下插入的行仍需提交。\nC.第二个ROLLBACK命令什么也不做。\nD.第二个ROLLBACK撤消了插入。\nE.第二个ROLLBACK命令重放了删除。",
        "answer": "B,D"
    },
    {
        "question": "\"检查下面的PRODUCTS表的描述：\n名称 Null? 类型\n---------------------------------------------------------------------------\nPROD_ID NOT NULL NUMBER(2)\nQTY NUMBER(5,2)\nCOST NUMBER(8,2)\n你成功执行了以下命令：\nCREATE TABLE new_prices (prod_id NUMBER(2),price NUMBER(8,2));\n哪两个语句可以成功执行？\nA.  MERGE INTO new_prices n\nUSING (SELECT * FROM products) p\nWHEN MATCHED THEN\n UPDATE SET n.price = p. cost*.01\nWHEN NOT MATCHED THEN\n INSERT (n.prod_id, n.pricE.  VALUES (p.prod_id, cost* .01)\nWHERE (p.cost < 200) ;\nB.  MERGE INTO new_prices n\nUSING (SELECT * FROM products WHERE cost> 150) p\nON (n.prod_id=p.prod_iD. \nWHEN MATCHED THEN\n DELETE WHERE (p.cost < 200)\nWHEN NOT MATCHED THEN\n INSERT (n.prod_id, n.pricE.  VALUES (p.prod_id, p.cost*.01);\nC.  MERGE INTO new_prices n\nUSING (SELECT * FROM products WHERE cost>150) p\nON (n.prod_id= p.prod_iD. \nWHEN MATCHED THEN\n UPDATE SET n.price= p.cost*.01\nDELETE WHERE (p.cost < 200);\nD.  MERGE INTO new_prices n\nUSING products p\nON (p.prod_id = n.prod_iD. \nWHEN NOT MATCHED THEN\n INSERT (n,prod_id, n.pricE.  VALUES (p.prod_id, p.cost*.01)\nWHERE (p.cost < 200);\"",
        "answer": "C,D"
    },
    {
        "question": "\"检查SALES1表的描述：\n名称 空？ 类型\n--------------------------------------------------------------------\nSALES_ID NOT NULL NUMBER\nSTORE_ID NOT NULL NUMBER\nITEMS_ID NUMBER\nQUANTITY NUMBER\nSALES_DATE DATE\nSALES2是一个与SALES1具有相同描述的表。\n一些销售数据在两个表中都有重复。\n您想显示SALES1表中不在SALES2表中的行。\n哪个集合运算符生成所需的输出？\nA. UNION ALL\nB. MINUS\nO) INTERSECT\nD. SUBTRACT\nE. UNION\"",
        "answer": "B"
    },
    {
        "question": "关于WITH GRANT OPTION子句，哪两个是正确的？\nA. 授权者可以将对象权限授予数据库中的任何用户，包括或不包括此选项\nB. 它可以被授权者用于将权限传递给其他用户\nC. 授权者必须具有GRANT ANY OBJECT PRIVILEGE系统特权才能使用此选项\nD. 它可用于系统和对象权限\nE. 在授予权限给角色时可以使用它。\nF. 授权者不能使用它将权限传递给PUBLIC。",
        "answer": "B,F"
    },
    {
        "question": "\"检查EMPLOYEES表的描述：\n名称 Null? 类型\n----------------------------------------------------------------------------\nEMP_ID NOT NULL NUMBER\nEMP_NAME VARCHAR2(10)\nDEPT_ID NUMBER (2)\nSALARY NUMBER(8,2)\nJOIN_DATE DATE\nNLS_DATE_FORMAT设置为DD-MON-YY。\n哪个查询需要显式数据类型转换？\nA. SELECT salary + '120.50' FROM employees;\nB. SELECT SUBSTR(join_date, 1, 2) - 10 FROM employees;\nC. SELECT join_date || ' ' || salary FROM employees;\nD. SELECT join_date FROM employees WHERE join_date>'10-02-2018';\nE. SELECT join_date + '20' FROM enployees;\"",
        "answer": "D"
    },
    {
        "question": "关于Oracle数据库中的时区、日期数据类型和时间戳数据类型，哪三个陈述是正确的？\n\nA. DBTIMEZONE函数可以返回与协调世界时（UTC）的偏移量。\nB. TIMESTAMP数据类型列包含有关年、月和日的信息。\nC. TIMESTAMP WITH LOCAL TIMEZONE数据类型列在数据库中使用插入行的会话的时区存储。\nD. SESSIONTIMEZONE函数可以返回与协调世界时（UTC）的偏移量。\nE. CURRENT_TIMESTAMP函数返回没有时区信息的数据。",
        "answer": "C,D"
    },
    {
        "question": "关于数据字典，哪两个说法是正确的？\nA. 所有用户操作都记录在数据字典中。\nB. 数据字典会不断更新以反映对数据库对象、权限和数据的更改。\nC. SYS用户拥有数据字典中所有基本表和用户可访问的视图。\nD. 数据字典中的基本表具有前缀DBA_。\nE. 所有用户默认具有访问数据字典中所有信息的权限。",
        "answer": "B,C"
    },
    {
        "question": "\"检查SALES表的描述：\n名称 空？ 类型\n-------------------------------------------------------------------------\nPRODUCT_id NOT NULL NUMBER(10)\nCUSTOMER_ID NOT NULL NUMBER(10)\nTIME_ID NOT NULL DATE\nCHANNEL_ID NOT NULL NUMBER(5)\nPROMO_ID NOT NULL NUMBER(5)\nQUANTITY_SOLD NOT NULL NUMBER(10,2)\nPRICE NUMBER(10,2)\nAMOUNT_SOLD NOT NULL NUMBER(10,2)\nSALES表有55,000行。\n检查以下语句：\nCREATE TABLE sales1 (prod_id,cust_id,quantity_sold,pricE. \nAS\nSELECT product_id,customer_id,quantity_sold,price\nFROM sales\nWHERE 1=1;\n哪两个陈述是正确的？\nA. SALES1在选择的列上具有主键和唯一约束，这些列在SALES表中具有这些约束\nB. SALES1创建了55,000行。\nC. SALES1创建了没有行。\nD. SALES1创建了1行。\nE. SALES1在选择的列上具有NOT NULL约束，这些列在SALES表中具有这些约束。\"",
        "answer": "B,E"
    },
    {
        "question": "哪三个陈述关于结构化查询语言(SQL)是正确的？\nA. 它最好支持关系型数据库。\nB. 它要求数据包含在分层数据存储中。\nC. 它保证原子性、一致性、隔离性和持久性(ACID)特性。\nD. 它是唯一可用于关系型和面向对象数据库的语言。\nE. 它用于定义关系表的封装和多态性。\nF. 它为被操作的逻辑数据结构提供与底层物理数据存储的独立性。",
        "answer": "C,D,F"
    },
    {
        "question": "\"检查CUSTOMERS表的描述：\n名称 Null? 类型\n-------------------------------------------------------------------\nCUST_ID NOT NULL VARCHAR2(2)\nCUST_LAST_NAME VARCHAR2(30)\nCITY VARCHAR2(10)\nCUST_CREDIT_LIMIT number(6,2)\n您需要显示所有姓氏以A或B开头（不区分大小写），并且信用额度低于1000的客户的姓氏和信用额度。\n检查这个部分查询：\nSELECT cust_last_name,cust_credit_limit FROM customers;\n哪两个WHERE条件可以得到所需的结果？\nA. WHERE (UPPER(cust_last_namE. LIKE INITCAP('A') OR UPPER(cust_last_namE. LIKE INITCAP('B')) AND ROUND(cust_credit_limit) < ROUND(1000);\nB. WHERE(UPPER(cust_last_namE. LIKE 'A%' OR UPPER(cust_last_namE. LIKE 'B%') AND ROUND(cust_credit_limit) < 1000;\nC. WHERE UPPER(cust_last_namE. IN ('A%','B%') AND cust_credit_limit < 1000;\nD. WHERE (INITCAP(cust_last_namE. LIKE 'A%' OR INITCAP(cust_last_namE. LIKE 'B%') AND cust_credit_limit < 1000;\nE. WHERE UPPER(cust_last_namE. BETWEEN UPPER('A%' AND 'B%') AND ROUND(cust_credit_limit) < 1000;\"",
        "answer": "B,D"
    },
    {
        "question": "选择两个\n检查这些成功执行的SQL语句\nCREATE TABLE emp\n(emp_no NUMBER(2) CONSTRAINT emp_emp_no_pk PRIMARY KEY,\nename VARCHAR2(15),\nsalary NUMBER(8,2),\nmgr_no NUMBER(2));\nALTER TABLE emp ADD CONSTRAINT emp_mgr_fk\nFOREIGN KEY(mgr_no)\nREFERENCES emp(emp_no)\nON DELETE SET NULL;\nALTER TABLE emp\nDISABLE CONSTRAINT emp_emp_no_pk\nCASCADE;\nALTER TABLE emp\nENABLE CONSTRAINT emp_emp_no_pk;\n执行后哪两个语句是正确的？\nA. 主键约束将被启用并延迟。\nB. 主键约束将被启用并立即执行。\nC. 外键约束将被启用并延迟。\nD. 外键约束将被启用并立即执行。\nE. 外键约束将被禁用。",
        "answer": "B,E"
    },
    {
        "question": "选择三个正确的说法关于权限和角色的：\nA. 一个角色可以包含多个权限和角色的组合。\nB. PUBLIC作为默认角色授予数据库中的每个用户。\nC. 系统权限总是为整个数据库设置权限。\nD. 用户默认拥有其模式中每个对象的所有对象权限。\nE. PUBLIC可以从用户中撤销。\nF. 角色由创建它的用户拥有。\nG. 所有角色都由SYS模式拥有。",
        "answer": "A,D,F"
    },
    {
        "question": "哪三个陈述关于Oracle连接和ANSI连接语法是正确的？\nA. 符合SQL:1999标准的ANSI连接语法支持创建两个表的笛卡尔积。\nB. Oracle连接语法的性能不如符合SQL:1999标准的ANSI连接语法。\nC. 符合SQL:1999标准的ANSI连接语法支持自然连接。\nD. Oracle连接语法的性能优于符合SQL:1999标准的ANSI连接语法。\nE. Oracle连接语法支持创建两个表的笛卡尔积。\nF. Oracle连接语法支持自然连接。\nG. Oracle连接语法仅支持右外连接。",
        "answer": "C,D,E"
    },
    {
        "question": "当与包含SET运算符（如UNION）的SQL语句一起使用时，关于ORDER BY子句的哪两个陈述是正确的？\nA. 仅识别复合查询中第一个SELECT语句中的列名。\nB. 复合查询中的每个SELECT语句都可以有自己的ORDER BY子句。\nC. 在缺少ORDER BY子句的情况下，默认使用带有UNION运算符的复合查询中第一个SELECT的第一列来对输出进行排序。\nD. 复合查询中的每个SELECT语句必须有自己的ORDER BY子句。\nE. 必须在ORDER BY子句中使用列位置。",
        "answer": "A,C"
    },
    {
        "question": "\"查看展示并检查PRODUCTS表的结构。哪两个任务需要子查询？\nA. 显示由供应商102提供的产品总数，这些产品的产品状态为过时。\nB. 显示PROD_LIST_PRICE高于平均PROD_LIST_PRICE的产品数量。\nC. 显示每个产品状态的最低PROD_LIST_PRICE。\nD. 显示PROD_LIST_PRICE低于1000的供应商。\nE. 显示PROD_MIN_PRICE高于所有产品的平均PROD_LIST_PRICE，并且状态为可订购的产品。\"",
        "answer": "B,E"
    },
    {
        "question": "\"检查PRODUCT_STATUS表的描述：\n名称 空？ 类型\n-------------------------------------------------------------------------------\nPROD_ID NOT NULL NUMBER(2)\nSTATUS NOT NULL VARCHAR2(15)\nSTATUS列包含每行的值'IN STOCK'或'OUT OF STOCK'。\n哪两个查询将成功执行？\nA. SELECT prod_id || q'('s not availablE. ' \"CURRENT AVAILABLITY\" FROM product _status WHERE \nstatus = 'OUT OF STOCK';\nB. SELECT prod_id q's not available\" FROM product_status WHERE status='OUT OF STOCK';\nC. SELECT prod_id || q'('s not availablE. ' 'CURRENT AVAILABILITY' FROM product_status WHERE \nstatus = 'OUT OF STOCK';\nD. SELECT prod_id || q'('s not avallablE. ' FROM product_status WHERE status='OUT OF STOCK';\nE. SELECT prod_id || q\"'s not available\" FROM product_status WHERE status='OUT OF STOCK';\nF. SELECT prod_id \"CURRENT AVAILABILITY\" || q'('s not availabiE. ' FROM product_status WHERE \nstatus ='OUT OF STOCK';\"",
        "answer": "A,D"
    },
    {
        "question": "选择三个正确的陈述关于数据操作语言（DML）？\nA. DELETE语句可以基于多个条件删除多个行。\nB. INSERT INTO...SELECT...FROM语句自动提交。\nC. INSERT语句可以显式地将NULL插入到列中。\nD. UPDATE语句可以有不同的子查询来指定每个更新列的值。\nE. DML语句要求在表上定义主键。",
        "answer": "A,C,D"
    },
    {
        "question": "在Oracle数据库中对视图执行数据操作语言（DML）操作的哪三个陈述是正确的？\nA. 通过视图始终可以在表上执行插入语句。\nB. 如果表具有主键并且主键列未在视图的定义查询中引用，则无法使用视图从底层表中查询行。\nC. 在通过视图删除底层表中的行时，WITH CHECK子句没有任何效果。\nD. 如果视图的定义查询包含DISTINCT关键字，则无法使用视图向底层表添加或修改行。\nE. 如果视图的定义查询包含聚合函数，则无法使用视图向底层表添加或修改行。\nF. 如果表具有NOT NULL约束的列缺少默认值且未在视图的定义查询中引用，则无法使用视图向底层表添加行。",
        "answer": "C,D,E,F"
    },
    {
        "question": "\"选择最佳答案\n您想编写一个查询，每次在会话中执行时提示两个列名和WHERE条件，但仅在第一次执行时提示表名。\n您查询中使用的变量在会话中从未未定义。\n哪个查询可以使用？\nA.  SELECT &col1, &col2\nFROM &&table\nWHERE &condition:\nB.  SELECT &col1,&scol2\nFROM \"&table\"\nWHERE &condition;\nC.  SELECT &&col1, &&col2\nFROM &table\nWHERE &&condition = &&cond;\nD.  SEIECT '&&col1', '&&col2'\nFROM &table\nWHERE '&&condition' = '&cond';\nE.  SELECT &&col1, &&col2\nFROM &table\nWHERE &&condition;\"",
        "answer": "A"
    },
    {
        "question": "\"选择两个\n检查TRANSACTIONS表的描述：\n名称 空？ 类型\n----------------------------------------------------------------------------\nTRANSACTION_ID NOT NULL VARCHAR2（6）\nTRANSACTION_DATE DATE\nAMOUNT NUMBER（10,2）\nCUSTOMER_ID VARCHAR2（6）\n哪两个SQL语句可以成功执行？\nA. SELECT customer_id AS 'CUSTOMER-ID'，transaction_date AS DATE，amount + 100 'DUES' FROM\ntransactions;\nB. SEIECT customer_id CUSTID，transaction_date TRANS_DATE，amount + 100 DUES FROM\ntransactions;\nC. SELECT customer_id AS“CUSTOMER-ID”，transaction_date AS“DATE”，amount + 100 DUES FROM\ntransactions;\nD. SELECT customer_id AS CUSTOMER-ID，transaction_date AS TRANS_DATE，amount + 100“DUES\nAMONT”FROM transactions;\nE. SELECT customer_id AS“CUSTOMER-ID”，transaction_date AS DATE，amount + 100“DUES”FROM\ntransactions;\"\n",
        "answer": "B,C"
    },
    {
        "question": "选择三个正确的陈述关于多行子查询？\nA. 它们可以包含GROUP BY子句。\nB. 它们可以包含HAVING子句。\nC. 它们可以返回多个列。\nD. 它们不能包含子查询。\nE. 子查询总是返回两个或更多的值。",
        "answer": "A,B,C"
    },
    {
        "question": "哪两个陈述关于全外连接是正确的？\nA. 它包括由笛卡尔积返回的行。\nB. 它包括由内连接返回的行。\nC. 它仅返回两个表中未匹配的行。\nD. 它返回两个表中匹配和未匹配的行。\nE. Oracle连接运算符(+)必须在WHERE子句中的连接条件的两侧使用。",
        "answer": "B,D"
    },
    {
        "question": "以下哪两个陈述关于基于实体关系图（ERD）从两个表中选择相关行是正确的？\n\nA. 在两个表之间实现关系可能需要连接其他表。\nB. 将来自同一表的数据与来自同一表的数据相关联是通过自连接实现的。\nC. 无关的表中的行不能连接。\nD. 两个表之间的每个关系都必须在连接条件中实现。\nE. 内连接将同一表中的行相关联。",
        "answer": "A,D"
    },
    {
        "question": "哪两个陈述关于替换变量是正确的？\nA. 以&为前缀的替换变量在会话中只提示一次值。\nB. 替换变量只能在SELECT语句中使用。\nC. 用于提示列名的替换变量必须用单引号括起来。\nD. 用于提示列名的替换变量必须用双引号括起来。\nE. 以&&为前缀的替换变量在会话中只提示一次值，除非在会话中未定义。\nF. 替换变量可以与SELECT语句中的任何子句一起使用。",
        "answer": "E,F"
    },
    {
        "question": "你执行了这个查询：\nSELECT TO_CHAR (NEXT_DAY (LAST_DAY (SYSDATE. , 'MON') , 'dd \"Monday for\" fmMonth rrrr' )\n FROM DUAL;\n结果是什么？\nA. 它成功执行但不返回任何结果。\nB. 它会生成一个错误。\nC. 它返回下个月第一个星期一的日期。\nD. 它返回当前月份的最后一个星期一的日期。",
        "answer": "C"
    },
    {
        "question": "\"表ORDER_ITEMS包含ORDER_ID、UNIT_PRICE和QUANTITY三个数据类型为NUMBER的列。\n请检查以下SQL语句：\n语句1：\nSELECT MAX(unit_price * quantity) \"最大订单\"\nFROM order_items;\n语句2：\nSELECT MAX(unit_price * quantity) \"最大订单\"\nFROM order_items\nGROUP BY order_id;\n哪两个语句是正确的？\nA. 如果UNIT_PRICE或QUANTITY包含NULL，则两个语句都将返回NULL。\nB. 语句2可能返回多行输出。\nC. 语句2只返回一行输出。\nD. 语句1只返回一行输出。\nE. 两个语句给出相同的输出。\"",
        "answer": "B,D"
    },
    {
        "question": "“表EMPLOYEES包含列，包括EMPLOYEE_ID、JOB_ID和SALARY。\n只有EMPLOYEE_ID列被索引。\n存在员工100和200的行。\n检查以下语句：\nUPDATE employees\nSET (job_id, salary) =\n(SELECT job_id, salary\nFROM employees\nWHERE employee_id = 200)\nWHERE employee_id = 100;\n哪两个语句是正确的？\nA. 员工100的SALARY将被设置为员工200的SALARY相同的值。\nB. 员工100和200的JOB_ID将与更新命令之前相同。\nC. 员工100的JOB_ID将被设置为员工200的JOB_ID相同的值。\nD. 员工100和200的SALARY将与更新命令之前相同。\nE. 员工200的SALARY将被设置为员工100的SALARY相同的值。\nF. 员工200的JOB_ID将被设置为员工100的JOB_ID相同的值。”",
        "answer": "A,C"
    },
    {
        "question": "你执行了这个命令：\nALTER TABLE employees SET UNUSED (department_iD)；\n哪两个是正确的？\nA. DEPARTMENT_ID列被设置为所有行中的null。\nB. 查询可以显示DEPARTMENT_ID列的数据。\nC. 无法对DEPARTMENT_ID列中的数据进行更新。\nD. 可以向EMPLOYEES表中添加一个名为DEPARTMENT_ID的新列。\nE. 可以从回收站中恢复DEPARTMENT_ID列。\nF. 只有在提交后，DEPARTMENT_ID列占用的存储空间才会被释放。",
        "answer": "C,D"
    },
    {
        "question": "\"检查CUSTOMERS表的描述：\n名称 空？ 类型\nCUSTNO NOT NULL NUMBER(3)\nCUSTNAME NOT NULL VARCHAR2 (25)\nCUSTADDRESS VARCHAR2 (35)\nCUST_CREDIT_LIMIT NUMBER(5)\nCUSTNO是主键。\n您必须确定是否有任何客户的详细信息已经使用不同的CUSTNO输入了多次，通过列出所有重复的名称来获取所需的结果。\n哪两种方法可以用来获得所需的结果？\nA. 自连接的全外连接\nB. 自连接的左外连接\nC. 自连接的右外连接\nD. 自连接\nE. 子查询\"",
        "answer": "D,E"
    },
    {
        "question": "关于复合查询中使用的INTERSECT运算符，哪个陈述是正确的？\nA. 它忽略NULL值。\nB. INTERSECT的优先级低于UNION或UNION ALL。\nC. 同一SQL语句中不可能有多个INTERSECT运算符。\nD. 它处理所选列中的NULL值。",
        "answer": "D"
    },
    {
        "question": "以下哪三个陈述关于单行子查询是正确的？\nA. 它们可以用在WHERE子句中。\nB. 它们必须放在比较运算符或条件的右侧。\nC. 它们必须返回一行以防止SQL语句出错。\nD. 它们必须放在比较运算符或条件的左侧。\nE. 一个SQL语句可以有多个单行子查询块。\nF. 它们可以用在HAVING子句中。",
        "answer": "A,C,E"
    },
    {
        "question": "\"检查MEMBERS表的描述：\n名称 Null? 类型\n------------------------- ----------------------- -----------------------\nMEMBER_ID NOT NULL VARCHAR2 (6)\nFIRST_NAME VARCHAR2(50)\nLAST_NAME NOT NULL VARCHAR2 (50)\nADDRESS VARCHAR2 (50)\nCITY VARCHAR2 (25)\n检查部分查询：\nSELECT city, last_name LNAME FROM members ...;\n您想显示所有包含字符串AN的城市。这些城市必须按升序返回，而姓氏必须按降序进一步排序。\n您必须添加哪两个子句到查询中？\nA. ORDER BY 1, LNAME DESC\nB. ORDER BY last_name DESC, city ASC\nC. WHERE city LIKE '%AN%'\nD. WHERE city = '%AN%'\nE. WHERE city IN ('%AN%')\nF. ORDER BY 1,2\"",
        "answer": "A,C"
    },
    {
        "question": "以下哪三个陈述关于Oracle同义词是正确的？\nA. 序列可以有同义词。\nB. 任何用户都可以删除公共同义词。\nC. 不能为PL/SQL包创建同义词。\nD. 由一个用户创建的同义词可以引用属于另一个用户的对象。\nE. 同义词可以对所有用户可用。",
        "answer": "A,D,E"
    },
    {
        "question": "以下哪三个陈述关于内置数据类型是正确的？\nA. BLOB在数据库中存储非结构化二进制数据。\nB. VARCHAR2列定义不需要指定长度。\nC. CHAR列定义不需要指定长度。\nD. BFILE在操作系统文件中存储非结构化二进制数据。\nE. CHAR列的默认长度始终为一个字符。\nF. 如果存储的数据是非数字且不包含特殊字符，则VARCHAR2空白填充列值。",
        "answer": "A,C,E"
    },
    {
        "question": "\"检查两个表的结构：\nPRODUCTS：\n名称 Null? 类型\n------------------------------------------------------------------------\nPROD_ID CHAR(2)\nPROD_NAME CHAR(4)\nEXP_DATE TIMESTAMP (6)\nNEW_PRODUCTS：\n名称 Null? 类型\n------------------------------------------------------------------------\nPROD_ID CHAR(4)\nPROD_NAME VARCHAR2 (10)\nEXP_DATE DATE\n哪两个查询可以成功执行？\nA.  SELECT prod_id, prod_name FROM products\nINTERSECT\n SELECT 100, prod_name FROM new_products;\nB.  SELECT prod_id FROM products\nUNION ALL\n SELECT prod_id, prod_name FROM new_products;\nC.  SELECT prod_id, exp_date FROM products\nUNION ALL\n SELECT prod_id, NULL FROM new_products;\nD.  SELECT * FROM products\nUNION\n SELECT * FROM new_products;\nE.  SELECT * FROM products\nMINUS\n SELECT prod_id FROM new_products;\"",
        "answer": "C,D"
    },
    {
        "question": "\"检查这个语句：\nSELECT 1 AS id, 'John' AS first_name\n FROM dual\nUNION\nSELECT 1, 'John' AS name\n FROM dual\nORDER BY 1;\n执行后返回什么？\nA. 0行\nB. 2行\nC. 1行\nD. 错误\"",
        "answer": "C"
    },
    {
        "question": "哪三个特权可以限制到表中的一部分列？\nA. REFERENCES\nB. INSERT\nC. SELECT\nD. ALTER\nE. UPDATE\nF. DELETE\nG. INDEX",
        "answer": "A,B,E"
    },
    {
        "question": "哪个陈述关于聚合函数是正确的？\nA. MAX和MIN函数可以用于字符数据类型的列。\nB. AVG函数隐式将NULL转换为零。\nC. 聚合函数可以在SELECT语句的任何子句中使用。\nD. 聚合函数可以嵌套到任意层级。",
        "answer": "A"
    },
    {
        "question": "\"在使用SET运算符（如INTERSECT）的复合查询中，SQL语句的默认排序输出的列是哪些？\nA. 复合查询中最后一个SELECT语句中的第一个NUMBER或VARCHAR2列\nB. 复合查询中第一个SELECT语句中的第一列\nC. 复合查询中第一个SELECT语句中的第一个VARCHAR2列\nD. 复合查询中第一个SELECT语句中的第一个NUMBER列\nE. 复合查询中最后一个SELECT语句中的第一列\"",
        "answer": "B"
    },
    {
        "question": "关于DESCRIBE命令，哪三个陈述是正确的？\nA. 它可以用于显示现有视图的结构。\nB. 它显示每个列定义的所有约束。\nC. 它显示具有NOT NULL约束的任何列的约束。\nD. 它可以从SQL Developer中使用。\nE. 它显示具有PRIMARY KEY约束的任何列或列的约束。\nF. 它只能从SQL*Plus中使用。",
        "answer": "A,C,D"
    },
    {
        "question": "关于UNION和UNION ALL运算符，哪两个陈述是正确的？\nA. 在重复检查期间，NULL不会被忽略。\nB. 输出由UNION ALL运算符排序。\nC. 每个SELECT语句中选择的列数必须相同。\nD. UNION ALL运算符会自动消除重复项。\nE. 每个SELECT语句中选择的列的名称必须相同。",
        "answer": "A,C"
    },
    {
        "question": "以下哪三个陈述关于索引是正确的？\nA. SELECT语句可以访问一个或多个索引而不访问任何表。\nB. 属于一个用户的表可以有属于另一个用户的索引。\nC. UNIQUE索引可以被更改为非唯一。\nD. 对表的更新可能导致表的任何索引都没有更新。\nE. 当一个表被删除并移动到回收站时，建立在该表上的所有索引都被永久删除。\nF. 对表的更新可能导致表的任何或所有索引都被更新。",
        "answer": "A,B,F"
    },
    {
        "question": "你可以通过使用ORACLE_DATAPUMP访问驱动程序执行哪三个操作？\nA. 创建一个外部表的目录对象。\nB. 从外部表中读取数据并将其加载到数据库中的表中。\nC. 查询外部表中的数据。\nD. 创建一个平面文件的目录对象。\nE. 在外部表上执行DML语句。\nF. 从数据库中的表中读取数据并将其插入到外部表中。",
        "answer": "A,B,C"
    },
    {
        "question": "哪两个陈述关于TRUNCATE和DELETE是正确的？\nA. TRUNCATE的结果可以通过发出ROLLBACK来撤消。\nB. TRUNCATE可以使用WHERE子句确定应该删除哪些行。\nC. DELETE的结果可以通过发出ROLLBACK来撤消。\nD. TRUNCATE使表上的任何索引处于不可用状态。\nE. DELETE可以使用WHERE子句确定应该删除哪些行。",
        "answer": "C,E"
    },
    {
        "question": "关于多表插入语句，哪三个说法是正确的？\nA. 它们可以在关系表上执行。\nB. 它们只能使用子查询执行。\nC. 它们可以在远程表上执行。\nD. 它们可以将每个计算行插入多个表中。\nE. 它们可以在使用SQL*Loader的外部表上执行。\nF. 它们可以在视图上执行。",
        "answer": "B,C,D"
    },
    {
        "question": "以下哪三个陈述关于Oracle数据库中的视图是正确的？\nA. 数据操作语言（DML）总是可以在视图上使用。\nB. 使用包含GROUP BY子句的定义查询的视图删除一个或多个行将导致错误。\nC. WITH CHECK子句可以防止在查询视图时显示某些行。\nD. WITH CHECK子句可以防止某些行被更新或插入。\nE. 使用包含GROUP BY子句的定义查询的视图插入一个或多个行将导致错误。\nF. 可以在不需要重新授予视图权限的情况下更新视图。\nG. 视图定义查询中的表必须始终存在才能创建视图。",
        "answer": "B,E,G"
    },
    {
        "question": "“STORES表有一个数据类型为DATE的START_DATE列，包含插入行的日期。\n您只想显示START_DATE在过去25个月内的行的详细信息。\n可以使用哪个WHERE子句？\nA. WHERE MONTHS_BETWEEN（SYSDATE，start_date）<= 25\nB. WHERE ADD_MONTHS（start_date，25）<= SYSDATE\nC. WHERE TO_NUMBER（start_date - SYSDATE）<= 25\nD. WHERE MONTHS_BETWEEN（start_date，SYSDATE）<= 25”",
        "answer": "A"
    },
    {
        "question": "\"查看展示并检查表的描述。您执行了以下SQL语句：\nINSERT INTO sales VALUES (\n23, 2300, SYSDATE,\n(SELECT channel_id\nFROM channels\nWHERE channel_desc = '直销'),\n12, 1, 500) ;\n哪三个陈述是正确的？\nA. 如果SALES表中已经存在产品23的行，则该语句将失败。\nB. SALES表有五个外键。\nC. 产品在不同时间可以有不同的单价。\nD. 该语句将成功执行，并将在SALES表中插入一行新数据。\nE. 该语句将失败，因为子查询不能包含在VALUES子句中。\nF. 一个客户可以存在于多个国家。\"",
        "answer": "B,C,D"
    },
    {
        "question": "\"使用ALTER TABLE命令可以执行以下哪三个操作？\nA.  限制表上的所有DML语句。\nB.  从表中删除伪列。\nC.  同时从表中删除所有列。\nD.  锁定表中的一组行。\nE.  重命名表。\nF.  启用或禁用表上的约束。\"",
        "answer": "A,E,F"
    },
    {
        "question": "以下哪三个陈述关于内连接和外连接是正确的？\nA. 全外连接返回匹配和未匹配的行。\nB. 外连接只能在每个查询中使用两个表。\nC. 当两个表存在多个连接条件时，可以使用外连接。\nD. 左外连接或右外连接仅返回未匹配的行。\nE. 全外连接必须使用Oracle语法。\nF. 内连接返回匹配的行。",
        "answer": "A,C,F"
    },
    {
        "question": "你可以对包含数据的现有表执行哪三个操作？\nA. 将包含数据的日期列更改为数字数据类型。\nB. 增加数字列的宽度。\nC. 添加一个新的非空列，其中包含默认值。\nD. 添加一个新列作为表的第一列。\nE. 更改列的默认值。\nF. 定义一个默认值，自动插入包含空值的列中。",
        "answer": "B,C,E"
    },
    {
        "question": "关于SET VERIFY ON命令，哪两个陈述是正确的？\nA. 它显示以&&为前缀的变量的值。\nB. 它显示仅在查询的WHERE子句中使用的变量的值。\nC. 它只能在SQL*Plus中使用。\nD. 它可以在SQL Developer和SQL*Plus中使用。\nE. 它显示由DEFINE命令创建的变量的值。",
        "answer": "A,C"
    },
    {
        "question": "\"一个Oracle数据库服务器会话中有一个未提交的事务正在进行中，它更新了一个表中的5000行数据。\n在哪三种情况下，事务会完成并提交更新？\nA. 当会话成功注销时\nB. 当DBA发出成功的SHUTDOWN IMMEDIATE语句并且用户随后发出COMMIT时\nC. 当DBA发出成功的SHUTDOWN TRANSACTIONAL语句并且用户随后发出COMMIT时\nD. 当在同一会话中成功执行CREATE INDEX语句时\nE. 当在同一数据库实例中的另一个会话中相同用户发出COMMIT语句时\nF. 当在同一会话中执行CREATE TABLE AS SELECT语句失败时\"",
        "answer": "C,D,F"
    },
    {
        "question": "以下哪四个关于Oracle表的约束条件是正确的？\nA. UNIQUE约束可以使用已有的索引来约束列或多列。\nB. UNIQUE约束允许NULL值。\nC. NOT NULL约束可以在表级别定义。\nD. CHECK约束可以引用其他行中的值。\nE. FOREIGN KEY列可以包含NULL值。\nF. PRIMARY KEY约束可以在表已创建并填充数据后添加。\nG. 一列只能有一个CHECK约束。",
        "answer": "B,E,F,G"
    },
    {
        "question": "在哪三种情况下，总是会启动一个新的事务？\nA. 在同一会话中发出第一个数据操作语言（DML）语句之后，发出COMMIT或ROLLBACK语句\nB. 在同一会话中成功完成CREATE TABLE语句后，发出CREATE INDEX语句\nC. 在同一会话中DML语句失败后，发出DML语句\nD. 在同一会话中发出SELECT语句后，发出CREATE TABLE语句\nE. 在同一会话中发出SELECT语句后，发出TRUNCATE语句\nF. 在同一会话中发出CREATE TABLE AS SELECT语句后，发出SELECT FOR UPDATE语句",
        "answer": "A,C,F"
    },
    {
        "question": "关于MERGE语句，哪三个是正确的？\nA. 它可以有条件地在多个表中更新、插入或删除行。\nB. 它可以使用子查询来生成源行。\nC. 它可以使用视图来生成源行。\nD. 它只能合并来自表的行。\nE. 它可以有条件地将来自多个表的行合并插入到单个表中。\nF. 它可以多次更新目标表的同一行。",
        "answer": "B,C,E"
    },
    {
        "question": "关于在对象上授予权限，哪两个是正确的？\nA. 只有对象的所有者才能将对象权限授予角色。\nB. 表所有者必须授予REFERENCES权限，以允许其他用户使用该表创建FOREIGN KEY约束。\nC. 对象的所有者默认获得该对象的所有对象权限。\nD. 只有对象的所有者才能将对象权限授予其他用户。\nE. WITH GRANT OPTION子句只能由DBA用户使用。",
        "answer": "B,C"
    },
    {
        "question": "关于ORDER BY子句，哪两个陈述是正确的？\nA. 只有在SELECT列表中指定的列才能在ORDER BY子句中使用。\nB. 列别名可以在ORDER BY子句中使用。\nC. 在字符排序中，值是区分大小写的。\nD. NULL值不包括在排序操作中。\nE. 如果数字值具有小数位，则以降序显示。",
        "answer": "B,C"
    },
    {
        "question": "评估以下成功执行的命令：\n\nCREATE SEQUENCE ord_seq\nINCREMENT BY 1\nSTART WITH 1\nMAXVALUE 100000\nCYCLE\nCACHE 5000;\n\nCREATE TABLE ord_items\nord_no NUMBER(4) DEFAULT ord_seq.NEXTVAL NOT NULL,\nitem_no NUMBER(3), qty NUMBER(3),\nexpiry_date DATE,\nCONSTRAINT it_pk PRIMARY KEY (ord_no, item_no)，\nCONSTRAINT ord_fk FOREIGN KEY (ord_no) REFERENCES orders (ord_no)) ;\n\n关于ORD_ITEMS表和ORD_SEQ序列，哪两个陈述是正确的？\n\nA. 任何插入ORD_ITEMS表中的行的用户必须被授予访问序列ORD_SEQ的权限。\nB. 序列ORD_SEQ在每5000个数字后循环回1，并且可以循环20次。\nC. 序列ORD_SEQ保证不会生成重复的数字。\nD. 当向ORD_ITEMS插入行并且没有为ORD_NO给出显式值时，列ORD_NO会从序列ORD_SEQ获取下一个数字。\nE. 如果删除序列ORD_SEQ，则插入ORD_ITEMS的行的默认值为ORD_NO将为NULL。",
        "answer": "A,D"
    },
    {
        "question": "\"检查PROMOTIONS表的描述：\n名称 Nu11? 类型\n-----------------------------------------------------------------------------\nPROMO_ID NOT NULL NUMBER(6)\nPROMO_NAME NOT NULL VARCHAR2 (30)\nPROMO_CATEGORY NOT NULL VARCHAR2 (30)\nPROMO_COST NOT NULL NUMBER(10,2)\n您想显示每个促销类别中唯一的促销成本。\n哪两个查询可以使用？\nA. SELECT promo_category, DISTINCT promo_cost FROM promotions ORDER BY \n2;\nB. SELECT DISTINCT promo_category, promo_cost FROM promotions ORDER BY \n1;\nC. SELECT DISTINCT promo_category || ' has ' || promo_cost AS COSTS FROM \npromotions ORDER BY 1;\nD. SELECT DISTINCT promo_cost || ' in ' || DISTINCT promo_category FROM \npromotions ORDER BY 1;\nE. SELECT promo_cost, promo_category FROM promotions ORDER BY by 1;\"",
        "answer": "B,C"
    },
    {
        "question": "哪两个查询成功执行？\nA. 从DUAL选择COALESCE（100，NULL，200）;\nB. 从DUAL选择NULLIF（100，100）;\nC. 从DUAL选择COALESCE（100，'A'）; ;\nD. 从DUAL选择NULLIF（100，'A'）;\nE. 从DUAL选择NULLIF（NULL，100）;",
        "answer": "A,B"
    },
    {
        "question": "关于运算符优先级的规则，哪两个陈述是正确的？\nA. 在SQL语句中，+二元运算符具有最高的优先级。\nB. 可以使用多个括号来覆盖表达式中运算符的默认优先级。\nC. NULLS会影响表达式中运算符的优先级。\nD. 连接运算符||在表达式中始终在加法和减法之前计算。\nE. 具有相等优先级的算术运算符在表达式中从左到右计算。",
        "answer": "B,E"
    },
    {
        "question": "关于TRUNCATE和DELETE，哪个陈述是正确的？\nA. 如果违反外键约束，您永远不能从表中删除行。\nB. 对于具有多个索引和触发器的表，DELETE比TRUNCATE更快。\nC. 如果违反外键约束，您永远不能截断表。\nD. 对于大型表，TRUNCATE比DELETE更快。",
        "answer": "C"
    },
    {
        "question": "关于多表插入语句，哪两个是正确的？\nA. 有条件的INSERT FIRST语句总是将一行插入单个表中。\nB. 它们总是使用子查询。\nC. 无条件的INSERT ALL语句必须在源表和目标表中具有相同数量的列。\nD. 它们可以将源表中的一行转换为目标表中的多行。\nE. 有条件的INSERT ALL语句通过聚合源行将行插入单个表中。",
        "answer": "B,D"
    },
    {
        "question": "关于主键和外键约束以及它们对表数据的影响，哪四个陈述是正确的？\nA. 主键和外键约束可以在列和表级别上定义。\nB. 只有主键可以在列和表级别上定义。\nC. 可以在父行被删除时自动从子表中删除具有外键的子行。\nD. 可以在父行被删除时保留具有外键的子行在子表中。\nE. 一个表只能有一个主键，但可以有多个外键。\nF. 外键列和父表主键列必须具有相同的名称。\nG. 一个表只能有一个主键和一个外键。",
        "answer": "A,C,D,E"
    },
    {
        "question": "关于MERGE语句，哪两个选项是正确的？\nA. WHEN NOT MATCHED子句可用于指定要执行的更新操作。\nB. WHEN NOT MATCHED子句可用于指定要执行的删除操作。\nC. WHEN NOT MATCHED子句可用于指定要执行的插入操作。\nD. WHEN MATCHED子句可用于指定要执行的插入操作。\nE. WHEN MATCHED子句可用于指定要执行的更新操作。",
        "answer": "C,E"
    },
    {
        "question": "你发出了这个命令：\nDROP TABLE hr.employees;\n哪三个陈述是正确的？\nA. HR.EMPLOYEES 上定义的所有索引都被删除。\nB. HR.EMPLOYEES 的同义词被删除。\nC. HR.EMPLOYEES 上定义的所有约束都被删除。\nD. 用于填充 HR.EMPLOYEES 表中列的序列被删除。\nE. HR.EMPLOYEES 表可以移动到回收站。\nF. 引用 HR.EMPLOYEES 的视图被删除。",
        "answer": "A,C,E"
    },
    {
        "question": "选择两个。\n关于SAVEPOINT，哪两个陈述是正确的？\nA. SAVEPOINT不会发出COMMIT。\nB. 回滚到SAVEPOINT可以撤消TRUNCATE语句。\nC. 回滚到SAVEPOINT可以撤消DELETE语句。\nD. 回滚到SAVEPOINT可以撤消CREATE INDEX语句。\nE. 在一个事务中只能发出一个SAVEPOINT。",
        "answer": "A,C"
    },
    {
        "question": "关于外部表，哪两个陈述是正确的？\nA. 只能使用 SQL 或 PL/SQL 检索它们的数据。\nB. 它们的元数据和实际数据都存储在数据库外部。\nC. 可以使用 CREATE TABLE AS SELECT 命令从数据库中现有的数据填充它们。\nD. 不能对它们使用 DML 语句。\nE. 可以在它们上创建索引。",
        "answer": "C,D"
    },
    {
        "question": "以下哪三个陈述关于单行函数是正确的？\nA. 它们只能接受一个参数。\nB. 它们可以嵌套到任何级别。\nC. 它们每个表只返回一个结果行。\nD. 返回的数据类型可以与参数的数据类型不同。\nE. 参数可以是列名、变量、文字或表达式。\nF. 它们只能在SELECT语句的WHERE子句中使用。",
        "answer": "B,D,E"
    },
    {
        "question": "关于视图，哪两个陈述是正确的？\nA. 视图可以更新而无需重新授予权限。\nB. 视图可以被索引。\nC. WITH CHECK子句可以防止通过视图更新或插入底层表中的某些行。\nD. WITH CHECK子句可以防止在查询视图时显示某些行。\nE. 视图定义查询中的表必须始终存在才能创建视图。",
        "answer": "A,C"
    },
    {
        "question": "关于在没有定义INSTEAD OF触发器的视图上执行数据操作语言（DML）操作，哪三个陈述是正确的？\nA. 如果视图的定义查询包含DISTINCT关键字，则无法使用视图向底层表添加或修改行。\nB. 可以始终通过视图在表上执行删除语句。\nC. 可以始终通过视图在表上执行插入语句。\nD. 如果表具有主键并且主键列未在视图的定义查询中引用，则无法使用视图查询底层表中的行。\nE. 如果表具有具有NOT NULL约束且缺少默认值的列，并且这些列未在视图的定义查询中引用，则无法使用视图向底层表添加行。\nF. 当通过视图从底层表中删除行时，WITH CHECK子句没有任何效果。",
        "answer": "A,E,F"
    },
    {
        "question": "关于系统和对象权限，哪三个是正确的？\nA. 添加指向另一个模式中的表的外键约束需要 REFERENCES 对象权限。\nB. 撤销使用 WITH GRANT OPTION 子句授予的对象权限具有级联效应。\nC. 在向 PUBLIC 授予对象权限时不能使用 WITH GRANT OPTION。\nD. 在向用户和角色授予对象权限时可以使用 WITH GRANT OPTION。\nE. 在另一个模式中的现有表中添加主键约束需要系统权限。\nF. 撤销使用 WITH ADMIN OPTION 授予的系统权限具有级联效应。",
        "answer": "A,B,E"
    },
    {
        "question": "在单个Oracle会话中执行以下语句：\nCREATE TABLE product (pcode NUMBER(2),pname VARCHAR2 (20));\nINSERT INTO product VALUES (1, 'pen') ;\nINSERT INTO product VALUES (2, 'pencil');\nINSERT INTO product VALUES (3, 'fountain pen');\nSAVEPOINT a;\nUPDATE product SET pcode = 10 WHERE pcode = 1;\nCOMMIT;\nDELETE FROM product WHERE pcode = 2;\nSAVEPOINT b;\nUPDATE product SET pcode = 30 WHERE pcode = 3;\nSAVEPOINT c;\nDELETE FROM product WHERE pcode = 10;\nROLLBACK TO SAVEPOINT b;\nCOMMIT;\n以下哪三个语句是正确的？\nA. 笔的代码是1。\nB. 没有包含钢笔的行。\nC. 钢笔的代码是3。\nD. 没有包含笔的行。\nE. 没有包含铅笔的行。\nF. 笔的代码是10。",
        "answer": "C,E,F"
    },
    {
        "question": "关于在表、视图和序列上授予对象权限，哪两个是正确的？\nA. 只能在表和序列上授予INSERT权限。\nB. 只能在表上授予REFERENCES权限。\nC. 可以在表、视图和序列上授予DELETE权限。\nD. 可以在表、视图和序列上授予SELECT权限。\nE. 只能在表和序列上授予ALTER权限。",
        "answer": "D,E"
    },
    {
        "question": "\"检查这个序列的要求清单：\n1. 名称：EMP_SEQ\n2. 第一个返回值：1\n3. 不允许重复。\n4. 提供要插入到EMPLOYEES.EMPLOYEE_ID列中的值。\n5. 减少值之间的间隔机会。\n哪两个语句将满足这些要求？\nA. CREATE SEQUENCE emp_seq START WITH 1 INCREMENT BY 1 CYCLE;\nB. CREATE SEQUENCE emp_seq START WITH 1 INCREMENT BY 1 CACHE;\nC. CREATE SEQUENCE emp_seq START WITH 1 CACHE;\nD. CREATE SEQUENCE emp_seq START WITH 1 INCREMENT BY 1 NOCACHE;\nE. CREATE SEQUENCE emp_seq NOCACHE;\nF. CREATE SEQUENCE emp_seq;\"",
        "answer": "D,E"
    },
    {
        "question": "关于在Oracle数据库中创建表，哪两个是正确的？\nA. 需要系统特权。\nB. 相同的表名可以用于不同模式中的表。\nC. 创建外部表将自动创建一个使用指定目录和文件名的文件。\nD. 主键约束是强制性的。\nE. CREATE TABLE语句可以指定表将包含的最大行数。",
        "answer": "A,B"
    },
    {
        "question": "以下哪三个关于子查询是正确的？\nA. 子查询可以在WHERE子句中使用。\nB. 子查询不能在选择列表中使用。\nC. < ANY返回true，如果参数小于子查询返回的最高值。\nD. 子查询可以在HAVING子句中使用。\nE. = ANY只能在子查询返回两个或更多值时对参数进行评估。\nF. 子查询不能在FROM子句中使用。\nG. < ANY返回true，如果参数小于子查询返回的最低值。",
        "answer": "A,C,D"
    },
    {
        "question": "\"检查CUSTOMERS表的描述：\n名称 空？ 类型\n----------------------------------------------------------------------------\nCUSTOMER_ID NOT NULL NUMBER(38)\nCUSTOMER NAME NOT NULL VARCHAR2 (100)\nINSERT_DATE NOT NULL DATE\n哪三个语句将进行隐式转换？\nA. SELECT * FROM customers WHERE TO_DATE (insert_datE. = DATE '2019-01-01';\nB. SELECT * FROM customers WHERE customer_id = '0001' ;\nC. SELECT * FROM customers WHERE TO_CHAR (customer_iD. = '0001' ;\nD. SELECT * FROM customers WHERE customer_id = 0001;\nE. SELECT * FROM customers WHERE insert_date = DATE '2019-01-01' ;\nF. SELECT * FROM customers WHERE insert_date = '01-JAN-19' ;\"",
        "answer": "B,E,F"
    },
    {
        "question": "\"检查这个部分语句：\nSELECT *\nFROM employees\nWHERE salary = (<subquery>);\n哪个是正确的？\nA. 查询和子查询都可以选择任意数量的行。\nB. 查询可以选择任意数量的行，但子查询只能选择零行或一行。\nC. 查询和子查询都只能选择零行或一行。\nD. 查询只能选择零行或一行，但子查询可以选择任意数量的行。\"",
        "answer": "B"
    },
    {
        "question": "哪个语句将成功执行？\nA. 从DUAL选择1,2\n UNION\n 从DUAL选择3,4\n 按1,2排序;\nB. 从DUAL选择1\n UNION\n 从DUAL选择2\n 按1,2排序;\nC. 从DUAL选择1,2\n UNION\n 从DUAL选择3,4\n 按3,4排序;\nD. 从DUAL选择3\n UNION\n 从DUAL选择4\n 按3排序;",
        "answer": "A"
    },
    {
        "question": "\"检查EMPLOYEES表的描述：\n名称 Null? 类型\n-------------------------------------------------------------------------------------\nEMP_NO NOT NULL NUMBER(5)\nLAST_NAME VARCHAR2 (10)\nDEPT_NO NOT NULL NUMBER(5)\nSALARY NUMBER(6,2)\n你写了这个失败的语句：\nSELECT dept_no AS department_id, MAX(salary) AS max_sal\n FROM employees\nWHERE salary > 10000\nGROUP BY department_id\nORDER BY max_sal;\n哪个子句导致了错误？\nA. GROUP BY\nB. SELECT\nC. WHERE\nD. ORDER BY\"",
        "answer": "A"
    },
    {
        "question": "\"检查BRICKS表中的数据：\n形状 重量\n--------------------------------------\n立方体 5\n长方体 10\n圆柱体 15\n检查BOXES表：\n箱子大小 最小重量 最大重量\n----------------------------------------------------------------------------\n小型 0 10\n哪两个查询仅返回立方体？\nA. 从砖块\n加入盒子\n在重量小于最大重量时;\nB. 从砖块\n加入盒子\n如果重量不大于最大重量，则为NOT;\nC. 从砖块\n加入盒子\n在重量大于最小重量时;\nD. 从砖块\n加入盒子\n在重量大于等于最小重量\n和重量小于最大重量时;\nE. 从砖块\n加入盒子\n在重量介于最小重量和最大重量之间时；\"",
        "answer": "A,D"
    },
    {
        "question": "关于未使用的列，哪两个是正确的？\n\nA. 查询可以从未使用的列返回数据，但这些列无法进行DML操作。\nB. 未使用的列保留其数据，直到它们被删除。\nC. 外键列不能设置为未使用。\nD. 一旦列被设置为未使用，就可以添加一个同名的新列到表中。\nE. 主键列不能设置为未使用。\nF. DESCRIBE命令显示未使用的列。",
        "answer": "B,D"
    },
    {
        "question": "哪个语句可以成功执行？\nA. SELECT TO_DATE (INTERVAL '800' SECOND, 'HH24:MM') FROM DUAL;\nB. SELECT TO_NUMBER (INTERVAL '800' SECOND, 'HH24:MM') FROM DUAL;\nC. SELECT TO_NUMBER (TO_DATE (INTERVAL '800' SECOND. ) FROM DUAL;\nD. SELECT TO_DATE (TO_NUMBER (INTERVAL '800' SECOND. ) FROM DUAL;\nE. SELECT TO_CHAR (INTERVAL '800' SECOND, 'HH24:MM') FROM DUAL;",
        "answer": "E"
    },
    {
        "question": "哪两个查询可以成功执行？\nA. 从DUAL中选择SYSTIMESTAMP + INTERVAL '1' DAY;\nB. 从DUAL中选择SYSDATE * INTERVAL '1' DAY;\nC. 从DUAL中选择INTERVAL '1' DAY - SYSDATE;\nD. 从DUAL中选择INTERVAL '1' DAY - INTERVAL '1' MINUTE;\nE. 从DUAL中选择INTERVAL '1' DAY + INTERVAL '1' MONTH;",
        "answer": "A,D"
    },
    {
        "question": "\"检查ORDERS表中的数据：\nORDER_ID ORDER_DATE\n-------------------------------------------------- ------\n1 <null>\n2 <null>\n3 01-JAN-2019\n4 01-FEB-2019\n5 01-MAR-2019\n检查INVOICES表中的数据：\nINVOICE_ID ORDER_ID ORDER_DATE\n-------------------------------------------------- ----------\n1 1 <null>\n2 2 01-JAN-2019\n3 3 <null>\n4 4 01-FEB-2019\n5 5 <null>\n检查此查询：\nSELECT order_id，order_date FROM orders\n减去\nSELECT order_id，order_date FROM invoices;\n它将返回哪三行？\nA. 5 <null>\nB. 1 <null>\nC. 3 <null>\nD. 5 01-MAR-2019\nE. 2 <null>\nF. 3 01-JAN-2019\nG. 4 01-FEB-2019\"",
        "answer": "D,E,F"
    },
    {
        "question": "\"实体关系模型的三个关键组成部分是哪三个？\nA. 关系\nB. 表格\nC. 唯一标识符\nD. 实体\nE. 属性\nF. 活动\"",
        "answer": "A,D,E"
    },
    {
        "question": "\"检查EMPLOYEES表的描述：\n名称 Null? 类型\n------------------------------------------------------------------------\nEMPLOYEE_ID NOT NULL NUMBER(6)\nEMPLOYEE_NAME NOT NULL VARCHAR2 (100)\nSALARY NOT NULL NUMBER\nCOMMISSION NUMBER\n哪三个查询返回SALARY + COMMISSION大于20000的所有行？\nA. SELECT * FROM employees WHERE salary + NVL2 (commission, commission, 0) >= 20000;\nB. SELECT * FROM employees WHERE salary + NULLIF (commission, 0) >= 20000;\nC. SELECT * FROM employees WHERE NVL2 (salary + commission, salary + commission, salary) >= \n20000;\nD. SELECT * FROM employees WHERE COALESCE (salary, commission) >= 20000;\nE. SELECT * FROM employees WHERE salary + NVL (commission, 0) >= 20000;\nF. SELECT * FROM employees WHERE NVL(salary + commission, 0) >= 20000;\"",
        "answer": "A,C,E"
    },
    {
        "question": "在您的会话中，NLS_DATE_FORMAT为DD-MM-YYYY。\n一天有86400秒。\n检查以下结果：\nDATE\n-------------------\n02-JAN-2020\n哪个语句返回此结果？\nA. SELECT TO_CHAR(TO_DATE('29-10-2019') + INTERVAL '2' MONTH + INTERVAL '5' DAY - INTERVAL \n'86410' SECOND, 'DD-MON-YYYY') AS \"date\"\nFROM DUAL;\nB. SELECT TO_CHAR(TO_DATE('29-10-2019') + INTERVAL '3' MONTH + INTERVAL '7' DAY - INTERVAL \n'360' SECOND, 'DD-MON-YYYY') AS \"date\"\nFROM DUAL;\nC. SELECT TO_CHAR(TO_DATE('29-10-2019') + INTERVAL '2' MONTH + INTERVAL '5' DAY - INTERVAL \n'120' SECOND, 'DD-MON-YYYY') AS \"date\"\nFROM DUAL;\nD. SELECT TO_CHAR(TO_DATE('29-10-2019') + INTERVAL '2' MONTH + INTERVAL '6' DAY - INTERVAL \n'120' SECOND, 'DD-MON-YYYY') AS \"date\"\nFROM DUAL;\nE. SELECT TO_CHAR(TO_DATE('29-10-2019') + INTERVAL '2' MONTH + INTERVAL '4' DAY - INTERVAL \n'120' SECOND, 'DD-MON-YYYY') AS \"date\"\nFROM DUAL;",
        "answer": "C"
    },
    {
        "question": "\"检查COUNTRIES表的描述：\n名称 空？ 类型\n-----------------------------------------------------------------------\nCOUNTRY_ID NOT NULL CHAR(2)\nCOUNTRY_NAME VARCHAR2 (40)\n检查DEPARTMENTS表的描述：\n名称 空？ 类型\n-------------------------------------------------------------------\nDEPARTMENT_ID NOT NULL NUMBER(4)\nDEPARTMENT_NAME NOT NULL VARCHAR2 (30)\nLOCATION_ID NUMBER(4)\n检查LOCATIONS表的描述：\n名称 空？ 类型\n------------------------------------------------------------------------\nLOCATION_ID NOT NULL NUMBER(4)\nADDRESS VARCHAR2 (140)\nCOUNTRY_ID CHAR (2)\n哪两个查询将返回没有部门的国家列表？\nA. 从国家中选择country_id，country_name\nMINUS\n从位置l\nJOIN国家c ON l.country_id = C.country_id\nJOIN部门d ON D.location_id = l.location_id;\nB. 从国家中选择country_id，country_name\nJOIN位置使用(country_iD. \nJOIN部门使用(location_iD. \nWHERE department_id is NULL;\nC. 从国家中选择country_id，country_name\nWHERE country_id NOT IN (\n从国家中选择country_id\nJOIN位置使用(country_iD. \nJOIN部门使用(location_iD. \n);\nD. 从国家中选择country_id，country_name\nINTERSECT\n从位置l\nJOIN国家c ON l.country_id = C.country_id\nJOIN部门d ON D.location_id = l.location_id; \"",
        "answer": "A,C"
    },
    {
        "question": "哪两个语句执行成功？\nA. 从DUAL中选择TO_CHAR('2019-DEC-25 15:30'，'YYYY-MON-DD HH24:MI'，'NLS_DATE_LANGUAGE = AMERICAN')\nB. 从DUAL中选择TO_DATE(TO_CHAR('2019-DEC-25 03:30'，'YYYY-MON-DD HH12:MI'))\nC. 从DUAL中选择TO_CHAR('2019-DEC-25 15:30'，'YYYY-MON-DD HH24:MI')\nD. 从DUAL中选择TO_DATE('2019-DEC-25 15:30'，'YYYY-MON-DD HH24:MI'，'NLS_DATE_LANGUAGE = AMERICAN')\nE. 从DUAL中选择TO_CHAR(TO_DATE('2019-DEC-25 03:30'，'YYYY-MON-DD HH12:MI'))",
        "answer": "D,E"
    },
    {
        "question": "\"检查INVOICES表中的数据：\nINVOICE_ID CURRENCY_CODE RAISED_DATE\n------------------------------------------------------------------------------------------------\n1 EUR 01-JAN-2019\n2 USD 01-FEB-2019\n3 JPY 01-MAR-2019 \n检查CURRENCIES表中的数据：\nCURRENCY_CODE\n------------------------------\nJPY\nGPB\nCAD\nEUR\nUSD\n哪个查询返回在CURRENCIES中而不在INVOICES中的货币？\nA. 选择货币代码从currencies中\n减去\n选择货币代码从发票中;\nB. 选择*从currencies中\n减去\n选择*从发票中;\nC. 选择*从currencies中\n其中不存在(\n选择NULL从发票中其中货币代码=货币代码：\n);\nD. 选择货币代码从currencies中\n交集\n选择货币代码从发票中。\"",
        "answer": "A"
    },
    {
        "question": "关于INVISIBLE索引，哪两个陈述是正确的？\nA. 所有的INSERT、UPDATE和DELETE语句都会维护索引中的条目。\nB. 在相同的列列表上只能创建一个INVISIBLE索引。\nC. INVISIBLE索引不消耗存储空间。\nD. 查询优化器在确定执行计划时从不考虑INVISIBLE索引。\nE. 使用ALTER INDEX将INVISIBLE索引变为VISIBLE。",
        "answer": "A,B,E"
    },
    {
        "question": "\"检查EMP表的内容：\nID NAME SALARY\n-------------------------------------------------- -\n101 John 26000\n102 Neena 24000\n103 DeHaan 12000\n104 Lex 17000\n105 Bill 18000\n106 Daniel 26000\n107 Ben 12000\n108 George 25000\n检查成功执行的查询：\nSELECT id，name，salary\nFROM emp\nORDER BY salary\nFETCH FIRST 5 ROWS WITH TIES;\n结果是什么？\nA.它将以降序返回五个薪水最高的员工。\nB.它将以升序返回六个薪水最低的员工。\nC.它将以降序返回六个薪水最高的员工。\nD.它将以升序返回五个薪水最低的员工。\"",
        "answer": "D"
    },
    {
        "question": "\"检查BRICKS表：\n颜色 形状 重量\n-------------------------------------------------- -\n红色 立方体 5\n红色圆柱体10\n蓝色 立方体 15\n蓝色圆柱体20\n你写了这个查询：\nSELECT *\nFROM bricks b1 CROSS JOIN bricks b2\nWHERE b1.weight < b2.weight;\n查询将返回多少行？\nA. 4\nB. 1\nC. 6\nD. 10\nE. 0\nF. 16\"",
        "answer": "C"
    },
    {
        "question": "\"检查这个不完整的查询语句：\nSELECT DATE '2019-01-01' + <INTERVAL CLAUSE>\nFROM DUAL;\n哪三个子句可以替换<INTERVAL CLAUSE>以将日期加12小时？\nA. INTERVAL '12:00' HOUR TO SECOND\nB. INTERVAL '720' MINUTE\nC. INTERVAL '12' HOUR\nD. INTERVAL '0.5' DAY\nE. INTERVAL '11:60' HOUR TO MINUTE\nF. INTERVAL '0 12' DAY TO HOUR\"",
        "answer": "B,C,F"
    },
    {
        "question": "关于ORDER BY子句，哪三个陈述是正确的？\nA. 默认情况下，ORDER BY子句按降序排序行。\nB. ORDER BY子句可以执行语言排序。\nC. ORDER BY子句可以执行二进制排序。\nD. 默认情况下，ORDER BY子句按升序排序行。\nE. 如果在同一顶层查询中同时使用HAVING子句和ORDER BY子句，则ORDER BY子句将始终在HAVING子句之前。\nF. ORDER BY子句总是将NULL值排序到最后。",
        "answer": "B,C,D"
    },
    {
        "question": "\"检查EMPLOYEES表的描述：\n名称 Null? 类型\n-----------------------------------------------------------------\nEMPLOYEE_ID NOT NULL NUMBER (3)\nFIRST_NAME VARCHAR2 (15)\nLAST_NAME NOT NULL VARCHAR2 (15)\nSALARY NUMBER(6,2)\n哪两个语句将成功运行？\nA.  SELECT 'The first_name is '' || first_name || '' FROM employees;\nB.  SELECT 'The first_name is \\'' || first_name || '\\'' FROM employees;\nC.  SELECT 'The first_name is ''' || first_name || ''' FROM employees;\nD.  SELECT 'The first_name is ' || first_name || ' ' FROM employees ;\nE.  SELECT 'The first_name is ''' || first_name || '''' FROM employees;\"",
        "answer": "D,E"
    },
    {
        "question": "你成功执行了以下命令：\nCREATE GLOBAL TEMPORARY TABLE invoices_gtt (\ncustomer_id INTEGER,\ninvoice_total NUMBER(10,2)\n) ON COMMIT PRESERVE ROWS;\nINSERT INTO invoices_gtt VALUES (1, 100) ;\nCOMMIT;\n以下哪两个是正确的？\nA. 要在此会话中删除表，必须先将其截断。\nB. 当您终止会话时，行将被删除。\nC. 其他会话可以查看已提交的行。\nD. 您可以向表添加外键。\nE. 您可以在此会话中向表添加列。",
        "answer": "A,B"
    },
    {
        "question": "\"你执行了以下命令：\nCREATE TABLE customers (customer_id INTEGER, customer_name VARCHAR2 (20)) ;\nINSERT INTO customers VALUES (1, 'Customer 1') ;\nSAVEPOINT post_insert; \nINSERT INTO customers VALUES (2, ' Customer 2') ;\n<TODO>\nSELECT COUNT(*) FROM customers;\n哪两个选项可以独立替换<TODO>，使查询返回1？\nA. COMMIT TO SAVEPOINT post_insert;\nB. ROLLBACK TO post_insert;\nC. COMMIT;\nD. ROLLBACK TO SAVEPOINT post_insert;\nE. ROLLBACK;\"",
        "answer": "B,D"
    },
    {
        "question": "关于Oracle同义词，哪两个陈述是正确的？\nA. 不能为序列创建同义词。\nB. 可以为角色创建同义词。\nC. 用户必须具有DBA角色才能创建公共同义词。\nD. 不能为同义词创建同义词。\nE. 可以为包创建同义词。\nF. 用户必须具有对基础对象所需的特权才能使用公共同义词。",
        "answer": "E,F"
    },
    {
        "question": "关于替换变量的&和&&前缀，哪个说法是正确的？\n\nA. &和&&都可以在查询和DML语句中作为替换变量名称的前缀。\nB. 即使会话中未定义替换变量，&&前缀也不会提示输入值。\nC. 对于未定义的替换变量，如果在多个查询中多次引用&&前缀，将会提示输入值多次。\nD. &只能在查询中作为替换变量名称的前缀。\nE. 对于未定义的替换变量，如果在同一查询中引用两次&前缀，将会提示输入值两次。",
        "answer": "A,E"
    },
    {
        "question": "一个关系的方向包含哪三个项目？\nA. 可选性\nB. 属性\nC. 标签\nD. 基数\nE. 唯一标识符\nF. 实体",
        "answer": "B,E,F"
    },
    {
        "question": "\"选择最佳答案。\n检查EMPLOYEES表的描述：\n名称 Null? 类型\n-----------------------------------------------------------------------\nEMP_NO NOT NULL NUMBER (4)\nLAST_NAME VARCHAR2 (10)\nHIRE_DATE DATE\nSALARY NUMBER(6,2)\n对于部门90中的每个员工，您想显示：\n1. 他们的姓氏\n2. 他们已经受雇的完整周数\n输出必须按周数排序，从最长服务的员工开始。\n哪个语句可以实现这一点？\nA.  SELECT last_name, ROUND( (SYSDATE - hire_datE.  / 7) AS tenure\nFROM employees\nWHERE department_id = 90\nORDER BY tenure DESC;\nB.  SELECT last_name, TRUNC( (SYSDATE - hire_datE.  / 7) AS tenure\nFROM employees\nWHERE department_id = 90\nORDER BY tenure;\nC.  SELECT last_name, ROUND( (SYSDATE - hire_datE.  / 7) AS tenure\nFROM employees\nWHERE department_id = 90\nORDER BY tenure;\nD.  SELECT last_name, TRUNC( (SYSDATE - hire_datE.  / 7) AS tenure\nFROM employees\nWHERE department_id = 90\nORDER BY tenure DESC;\"",
        "answer": "A"
    },
    {
        "question": "关于使用集合运算符（如UNION）的查询，哪两个是正确的？\nA. 第一个SELECT列表中的表达式必须有一个列别名。\nB. 在包含多个集合运算符的查询中，INTERSECT始终优先于UNION和UNION ALL。\nC. 使用集合运算符的查询不会在数据类型组之间执行隐式转换（例如字符、数字等）。\nD. 使用集合运算符的CHAR列返回一个长度等于最长CHAR值的VARCHAR2。\nE. 所有数据类型的列都可以使用集合运算符。",
        "answer": "C,D"
    },
    {
        "question": "关于运算符和条件的优先级，哪两个是正确的？\nA. || 的优先级高于 +（加法）。\nB. 运算符在条件之前被评估。\nC. AND 和 OR 在条件中具有相同的优先级。\nD. NOT 在条件中的优先级高于 AND 和 OR。\nE. +（加法）的优先级高于*（乘法）。",
        "answer": "B,D"
    },
    {
        "question": "\"检查以下成功执行的语句：\nCREATE USER finance IDENTIFIED BY pwfin; \nCREATE USER fin_manager IDENTIFIED BY pwmgr;\nCREATE USER fin_clerk IDENTIFIED BY pwclerk;\nGRANT CREATE SESSION TO finance, fin_clerk;\nGRANT SELECT ON scott.emp TO finance WITH GRANT OPTION;\nCONNECT finance/pwfin\nGRANT SELECT ON scott.emp TO fin_clerk;\n哪两个是正确的？\nA. 删除用户FINANCE将自动从用户FIN_CLERK中撤销对SCOTT.EMP的SELECT权限。\nB. 从用户FINANCE中撤销对SCOTT.EMP的SELECT权限也会从用户FIN_CLERK中撤销该权限。\nC. 用户FINANCE无法将ALL权限授予FIN_MANAGER。\nD. 用户FIN_CLERK可以将SELECT权限授予用户FIN_MANAGER。\nE. 用户FINANCE可以将CREATE SESSION权限授予用户FIN_MANAGER。\"",
        "answer": "A,B"
    },
    {
        "question": "\"检查以下语句：\nCREATE TABLE employees\n(emp_id NUMBER(5) PRIMARY KEY,\nename VARCHAR2 (15) ,\nemail VARCHAR2(40) UNIQUE,\naddress LONG ,\nresume LONG,\ndept_id NUMBER(3) CONSTRAINT emp_dept_id_fk REFERENCES departments (dept_iD.  ,\nCONSTRAINT ename_nn NOT NULL\n);\n为了使其成功执行，必须更改哪两个内容？\nA. 在列级别而不是表级别上定义ENAME的NOT NULL约束。\nB. 在表级别而不是列级别上定义DEPT_ID的外键约束。\nC. 必须将LONG列中的一个更改为VARCHAR2或CLOB。\nD. 在DEPT_ID的外键约束中，将CONSTRAINT一词更改为FOREIGN KEY。\nE. EMP_ID的主键约束必须有一个名称。\"",
        "answer": "A,C"
    },
    {
        "question": "\"选择所有正确的陈述。\n关于Oracle数据库和SQL，哪两个陈述是正确的？\nA. 一个用户可以是同一个数据库中多个模式的所有者。\nB.  当执行UPDATE语句时，数据库实例会锁定每个更新的行。\nC.  数据库保证在用户创建的表的选择级别上具有读一致性。\nD.  查询只能访问同一个模式中的表。\nE.  数据库用户执行的更新可以通过使用ROLLBACK命令被另一个用户回滚。\"",
        "answer": "B,C"
    },
    {
        "question": "关于回滚，哪两个是正确的？\nA. ROLLBACK语句不会释放由表更新引起的锁定。\nB. 系统故障中断的事务会自动回滚。\nC. 数据控制语言（DCL）语句，如GRANT和REVOKE，可以回滚。\nD. 如果使用ROLLBACK语句而没有使用TO SAVEPOINT，则事务中的所有保存点都将被删除。\nE. 回滚后不能保证数据一致性。",
        "answer": "B,D"
    },
    {
        "question": "哪两个陈述关于实体关系是正确的？\nA. 当从具有自我引用关系的表中选择数据时，表名只能指定一次。\nB. 一个方向上的一对多关系在另一个方向上是一对一关系。\nC. 只能通过使用外键来实现多对多关系。\nD. 关系对于两个实体都是强制性的。\nE. 一对一关系总是自引用关系。",
        "answer": "B,D"
    },
    {
        "question": "\"检查NEW_EMPLOYEES表中的数据：\n员工ID 姓名 部门ID 经理ID 工作ID 薪水\n--------------------------------------------------------------------------------------------------------------------------------\n101 David 20 120 SA_REP 14000\n102 Sam 10 105 CLERK 12500\n103 Andrew 20 120 FIN_ADMIN 14200\n104 Adrian 30 108 MAR_CLERK 12500\n105 Maria 30 108 FIN_ADMIN 15000\n106 Tracy 40 110 AD_ASST 13000\n108 Kate 30 110 FIN_DIR 16500\n110 Anne 40 120 EX_DIR 18000\n120 Fran 20 110 SQ_DIR 16500\n检查EMPLOYEES表中的数据：\n员工ID 姓名 工作ID 薪水\n-----------------------------------------------------------------------------\n101 David CLERK 14000\n102 Sam SA_REP 11500\n104 Adrian MAR_CLERK 12500\n108 Kate FIN_DIR 16500\n110 Annie EX_DIR 18000\n你想要：\n1. 更新EMPLOYEES表中现有员工的详细信息，使用NEW_EMPLOYEES表中的数据。\n2. 将NEW_EMPLOYEES表中的新员工详细信息添加到EMPLOYEES表中。\n哪个语句可以实现这个目标？\nA. MERGE INTO employees e\n USING new_employees ne\n ON (E.employee_id= nE.employee_iD. \n WHEN FOUND THEN UPDATE SET E.name=nE.name, E.job_id= nE.job_id, E.salary= nE.salary\n WHEN NOT FOUND THEN INSERT VALUES (nE.employee_id, ne .name, nE.job_id, nE.salary);\nB. MERGE INTO employees e\n USING new_employees ne\n WHERE E.employee_id= nE.employee_id\n WHEN FOUND THEN UPDATE SET E.name= nE.name, E.job_id= nE.job_id, E.salaly= nE.salary\n WHEN NOT FOUND THEN INSERT VALUES (nE.employee_id, nE.name, nE.job_id, nE.salary) ;\nC. MERGE INTO employees e\n USING new_employees ne\n WHERE E.employee_id= nE.employee_id\n WHEN MATCHED THEN UPDATE SET E.name= nE.name, E.job_id= nE.job_id, E.salary= nE.salary\n WHEN NOT MATCHED THEN INSERT VALUES (nE.employee id, nE.name, nE.job_id, nE.salary) :\nD. MERGE INTO employees e\n USING new_employees ne\n ON (E.employee_id= ne .employee_iD. \n WHEN MATCHED THEN UPDATE SET E.name=nE.name, E.job_id= nE.job_id, E.salary= nE.salary\n WHEN NOT MATCHED THEN INSERT VALUES (nE.employee_id, nE.name, nE.job_id, nE.salary);\"",
        "answer": "D"
    },
    {
        "question": "选择最佳答案\n检查以下语句和结果：\nSQL> SELECT COUNT(*) FROM emp;\nCOUNT (*)\n--------------------\n14\nSQL> CREATE GLOBAL TEMPORARY TABLE t_emp AS SELECT * FROM emp;\n表已创建。\nSQL> INSERT INTO t_emp SELECT * FROM emp;\n创建了14行。\nSQL> COMMIT;\n提交完成。\nSQL> INSERT INTO t_emp SELECT * FROM emp;\n创建了14行。\nSQL> SELECT COUNT(*) FROM t_emp;\n最后一个查询检索到多少行？\nA. 0\nB. 14\nC. 28\nD. 42",
        "answer": "B"
    },
    {
        "question": "\"检查COLORS表中的数据：\nRGB_HEX_VALUE COLOR_NAME\n-------------------------------------------------- ----------\nFF0000红色\n00FF00绿色\n0000FF蓝色\n检查BRICKS表中的数据：\nBRICK_ID COLOR_RGB_HEX_VALUE\n-------------------------------------------------- ----------\n1 FF0000\n2 00FF00\n3 FFFFFF\n哪两个查询返回COLORS中的所有行？\nA.选择*\n从颜色c\n左连接砖块b\n使用（rgb_hex_valuE。\nB.选择*\n从砖b\n完整连接颜色c\nON B.color_rgb_hex_value = C.rgb_hex_value;\nC.选择*\n从颜色c\n左连接砖块b\nON B.color_rgb_hex.value = C.xgb_hex_value\nWHERE B.brick_id> 0;\nD.选择*\n从砖b\n加入颜色c\nON B.color_rgb_hex_value = C.rgb_hex_value;\nE.选择*\n从砖b\n右连接颜色c\nON B.color_rgb_hex_value = C.rgb_hex_value; \"",
        "answer": "B,E"
    },
    {
        "question": "\"检查这个部分语句：\nSELECT ename, sal, comm FROM emp\n现在检查这个输出：\nENAME SAL COMM\n-------------------------------------------------\nMARTIN 1250 1400\nHARD 1250 500 \nALLEN 1600 300\nTURNER 1500 0\nALLEN 1100 \nBLAKE 2850\nCLARK 2450\nFORD 3000\nJAMES 950\nJONES 2975\nKING 5000\nMILLER 1300\nSCOTT 3000\nSMITH 800\n哪个ORDER BY子句将生成显示的输出？\nA. ORDER BY comm DESC NULLS LAST, ename\nB. ORDER BY NVL(comm, 0) DESC, ename\nC. ORDER BY NVL(comm, 0) ASC NULLS LAST, ename\nD. ORDER BY NVL(comm, 0) ASC NULLS FIRST, ename\"",
        "answer": "B"
    },
    {
        "question": "\"检查这个查询：\nSELECT SUBSTR (SYSDATE, 1,5) \"Result\" FROM DUAL;\n哪个陈述是正确的？\nA. 除非表达式修改为TO_CHAR (SUBSTR (SYSDATE, 1, 5))，否则它会失败。\nB. 除非表达式修改为SUBSTR (TO_CHAR (SYSDATE. , 1, 5)，否则它会失败。\nC. 除非表达式修改为SUBSTR (TO_CHAR (TRUNC (SYSDATE. ), 1, 5)，否则它会失败。\nD. 它通过隐式数据类型转换成功执行。\"",
        "answer": "D"
    },
    {
        "question": "关于全局临时表，哪两个是正确的？\nA. 可以对这些表进行备份和恢复操作。\nB. 它们的数据始终存储在创建它们的用户的默认临时表空间中。\nC. 如果ON COMMIT子句是事务特定的，则在每个COMMIT或ROLLBACK后删除表中的所有行。\nD. 可以在它们上创建索引。\nE. 它们只能由具有DBA角色的用户创建，但可以被所有可以创建会话的用户访问。\nF. 如果ON COMMIT子句是会话特定的，则在会话终止时删除表。",
        "answer": "C,D"
    },
    {
        "question": "哪两个陈述是正确的？\nA. 使用DECODE评估的所有条件也可以使用CASE评估。\nB. CASE是一个函数，而DECODE不是。\nC. CASE和DECODE都不是函数。\nD. 使用CASE评估的所有条件也可以使用DECODE评估。\nE. CASE和DECODE都是函数。\nF. DECODE是一个函数，而CASE不是。",
        "answer": "A,E"
    },
    {
        "question": "关于CURRENT_TIMESTAMP，哪三个陈述是正确的？\nA. 值取决于SESSIONTIMEZONE的设置。\nB. 日期在DBTIMEZONE的时区。\nC. 返回数据类型为TIMESTAMP的值。\nD. 时间在DBTIMEZONE的时区。\nE. 返回与CURRENT_DATE相同的日期。\nF. 总是返回与SYSTIMESTAMP相同的值。\nG. 返回与CURRENT_DATE相同的时间。",
        "answer": "A,C,E"
    },
    {
        "question": "哪两个语句会导致数据字典的更改？\nA. TRUNCATE TABLE emp;\nB. DELETE FROM scott.emp;\nC. SELECT * FROM user_tab_privs;\nD. ALTER SESSION SET NLS_DATE_FORMAT = ' DD/MM/ YYYY' ;\nE. GRANT UPDATE ON scott.emp TO fin_manager;",
        "answer": "A,E"
    },
    {
        "question": "\"检查EMPLOYEES表中的数据：\nID LAST_NAME SALARY DEPT_ID\n--------------------------------------------------------------------------------\n1 Smith 1000 10\n2 Jones 2000 10\n3 Markham 1500 20\n4 Black 1300 20\n哪个语句将成功执行？\nA.  SELECT dept_id, STDDEV (last_namE. , SUM(salary) FROM employees GROUP BY dept_id;\nB.  SELECT dept_id, INSTR(last_name, 'A'), SUM(salary) FROM employees GROUP BY dept_id;\nC.  SELECT dept_id, LENGTH(last_namE. , SUM(salary) FROM employees GROUP BY dept_id;\nD.  SELECT dept_id, MAX(last_namE. , SUM(salary) FROM employees GROUP BY dept_id;\"",
        "answer": "D"
    },
    {
        "question": "关于NVL、NVL2和COALESCE函数，哪两个是正确的？\n\nA. NVL必须具有相同数据类型的表达式。\nB. COALESCE在找到第一个空值时停止评估表达式列表。\nC. COALESCE在找到第一个非空值时停止评估表达式列表。\nD. NVL2可以在列表中具有任意数量的表达式。\nE. NVL可以在列表中具有任意数量的表达式。\nF. NVL2中的第一个表达式永远不会被返回。",
        "answer": "A,C"
    },
    {
        "question": "\"检查以下语句和结果：\nCREATE SEQUENCE customer_seq CACHE 10;\nSELECT customer_seq. NEXTVAL FROM DUAL;\nNEXTVAL\n-----------------\n1\n现在检查以下命令：\nALTER SEQUENCE customer_seq <MISSING CLAUSE>;\n必须用什么替换 MISSING CLAUSE 才能使 CUSTOMER_SEQ. NEXTVAL 返回 11？\nA. INCREMENT BY 10\nB. START WITH 11\nC. NOCACHE\nD. MINVALUE 11\nE. CYCLE 11\"",
        "answer": "A"
    },
    {
        "question": "哪两个查询返回字符串“Hello！我们准备好了”？\nA. 从DUAL选择'Hello！我们准备好了';\nB. 从DUAL选择q'[Hello！我们准备好了]';\nC. 从DUAL选择'Hello！我们\\'准备好了' ESCAPE '\\';\nD. 从DUAL选择“Hello！我们准备好了”;\nE. 从DUAL选择q'！Hello！我们准备好了！'。",
        "answer": "B,E"
    },
    {
        "question": "关于保存点，哪两个是正确的？\nA. 发出保存点后，您不能回滚完整的事务。\nB. 它们使未提交的更新对同一用户拥有的其他会话可见。\nC. 它们使未提交的更新对其他用户拥有的会话可见。\nD. 在事务开始之前发出ROLLBACK TO SAVEPOINT命令会导致错误。\nE. 发出保存点后，您可以在当前事务中回滚到保存点名称。\nF. 您可以提交在两个保存点之间完成的更新，而不提交当前事务中的其他更新。",
        "answer": "D,E"
    },
    {
        "question": "“哪三个查询成功执行？\nA.  SELECT SYSDATE - DATE '2019-01-01' - 1 FROM DUAL;\nB.  SELECT 1 - SYSDATE - DATE '2019-01-01' FROM DUAL;\nC.  SELECT SYSDATE - 1 - DATE '2019-01-01' FROM DUAL;\nD.  SELECT 1 / SYSDATE - DATE '2019-01-01' FROM DUAL;\nE.  SELECT (SYSDATE - DATE '2019-01-01') / 1 FROM DUAL; \nF.  SELECT SYSDATE / DATE '2019-01-01' - 1 FROM DUAL;”",
        "answer": "A,C,E"
    },
    {
        "question": "哪两个语句将返回三名薪资最低的员工的姓名？\nA. 选择 last_name, salary\n从 (选择 * 从员工排序)\nWHERE ROWNUM <= 3;\nB. 选择 last_name, salary\n从员工\n按薪资排序\n仅获取前3行;\nC. 选择 last_name, salary\n从员工\nWHERE ROWNUM <= 3\n按 (选择员工的薪资) 排序;\nD. 选择 last_name, salary\n从员工\n仅获取前3行\n按薪资排序;\nE. 选择 last_name, salary\n从员工\nWHERE ROWNUM <= 3\n按薪资排序;",
        "answer": "A,B"
    },
    {
        "question": "哪个语句将返回 EMP_SEQ 序列生成的最后一个序列号？\nA.  SELECT emp_seq. CURRVAL FROM DUAL;\nB.  SELECT CURRVAL FROM emp_seq;\nC.  SELECT NEXTVAL FROM emp_seq;\nD.  SELECT emp_seq . NEXTVAL FROM DUAL;",
        "answer": "A"
    },
    {
        "question": "一个会话的NLS_DATE_FORMAT设置为DD Mon YYYY。\n哪两个查询返回值为1 Jan 2019？\nA. SELECT TO_DATE('2019-01-01', 'YYYY-MM-DD') FROM DUAL;\nB. SELECT DATE '2019-01-01' FROM DUAL;\nC. SELECT TO_CHAR('2019-01-01') FROM DUAL;\nD. SELECT TO_DATE('2019-01-01') FROM DUAL;\nE. SELECT '2019-01-01' FROM DUAL;",
        "answer": "A,B"
    },
    {
        "question": "\"检查这个部分查询：\nSELECT ch. channel_type, t. month, co. country_code, SUM(s. amount_solD.  SALES\nFROM sales s, times t, channels ch, countries co\n WHERE s. time_id = t. time_id\nAND s. country_id = co. country_id\nAND s. channel_id = ch. channel_id\nAND ch. channel_type IN ('直销', '互联网')\nAND t. month IN ('2000-09', '2000-10')\nAND co. country_code IN ('GB', 'US')\n检查这个输出：\nCHANNEL_TYPE MONTH CO SALES\n------------------------------------------------------------------------------------------------\n互联网 2000-09 GB 16569\n互联网 2000-09 US 124224\n互联网 2000-09 140793\n互联网 2000-10 GB 14539\n互联网 2000-10 US 137054\n互联网 2000-10 151593\n互联网 292387\n直销 2000-09 GB 85223\n直销 2000-09 US 638201\n直销 2000-09 723424\n直销 2000-10 GB 91925\n直销 2000-10 US 682297\n直销 2000-10 774222\n直销 1497646\n哪个GROUP BY子句必须添加，以便查询返回所示的结果？\nA. GROUP BY ch. channel_type, t. month, co. country_code;\nB. GROUP BY ch. channel_type, ROLLUP (t .month, co. country_codE. ;\nC. GROUP BY CUBE (ch. channel_type, t .month, co. country_codE. ;\nD. GROUP BY ch. channel_type, t .month, ROLLUP (co . country_codE. ;\"",
        "answer": "B"
    },
    {
        "question": "\"检查这个成功执行的语句：\nINSERT ALL\nWHEN SAL > 20000 THEN\nINTO special_sal VALUES (EMP_ID, SAL)\nELSE\nINTO sal_history VALUES (EMP_ID, HIREDATE, SAL)\nINTO mgr_history VALUES (EMP_ID, MGR, SAL)\nSELECT employee_id EMP_ID, hire_date HIREDATE, salary SAL, manager_id MGR\nFROM employees\nWHERE employee_id < 125;\n以下哪三个是正确的？\nA. 如果工资低于或等于20000且员工ID小于125，则将EMPLOYEE_ID、HIRE_DATE和SALARY插入到SAL_HISTORY表中。\nB. 如果工资高于20000且员工ID小于125，则将EMPLOYEE_ID和SALARY插入到SPECIAL_SAL表中。\nC. 只有当工资低于或等于20000且员工ID大于或等于125时，才将EMPLOYEE_ID、MANAGER_ID和SALARY插入到MGR_HISTORY表中。\nD. 无论工资如何，只有当员工ID小于125时，才将EMPLOYEE_ID、MANAGER_ID和SALARY插入到MGR_HISTORY表中。\nE. 无论工资和员工ID如何，都将EMPLOYEE_ID、MANAGER_ID和SALARY插入到MGR_HISTORY表中。\nF. 只有当工资低于或等于20000且员工ID小于125时，才将EMPLOYEE_ID、MANAGER_ID和SALARY插入到MGR_HISTORY表中。\"",
        "answer": "A,B,F"
    },
    {
        "question": "\"你必须找出薪水低于员工110的员工人数。\n哪个语句无法完成这个任务？\nA. 选择计数（*）\n从员工e\n加入员工a\n在E.salary < A. salary\n其中A.employee_id = 110;\nB. 选择计数（*）\n从员工e\n加入（选择薪水从员工中的员工WHERE employee_id = 110）a\n在E.salary < A. salary;\nC. 选择计数（*）\n从员工e\n其中E.salary <（选择A.薪水从员工a WHERE E.employee_id = 110）;\nD. 选择计数（*）\n从员工\n其中薪水 <（选择薪水从员工WHERE employee_id = 110）;\"",
        "answer": "D"
    },
    {
        "question": "你和你的同事Andrew在EMPLOYEE_RECORDS表上拥有以下权限：\n1. SELECT\n2. INSERT\n3. UPDATE\n4. DELETE\n你连接到数据库实例并对EMPLOYEE_RECORDS中的一些行进行更新，但尚未提交。\nAndrew连接到数据库实例并查询表。\n没有其他用户访问该表。\n此时哪两个陈述是正确的？\nA. Andrew将无法看到你所做的更改。\nB. Andrew将能够看到你所做的更改。\nC. Andrew将能够修改表中未被你的事务修改的任何行。\nD. Andrew将能够从表中进行SELECT，但无法修改任何现有行。\nE. Andrew将无法在表上执行任何INSERT、UPDATE或DELETE操作。",
        "answer": "A,C"
    },
    {
        "question": "关于标量子查询表达式，哪三个是正确的？\nA. 返回零行的标量子查询表达式计算结果为零。\nB. 它们可以用作CREATE TABLE语句中列的默认值。\nC. 它们不能用于GROUP BY子句中。\nD. 返回零行的标量子查询表达式计算结果为NULL。\nE. 它们不能用于INSERT语句的VALUES子句中。\nF. 它们可以嵌套使用。",
        "answer": "D,E,F"
    },
    {
        "question": "\"检查以下语句：\nCREATE TABLE orders \n(serial_no NUMBER UNIQUE,\norder_id NUMBER PRIMARY KEY,\norder_date DATE NOT NULL,\nstatus VARCHAR2 (10) CHECK (status IN ('CREDIT', 'CASH')) ,\nproduct_id NUMBER REFERENCES products (product_iD.  ,\norder_total NUMBER) ;\n在这个表中哪两列会自动创建索引？\nA. STATUS\nB. ORDER_TOTAL\nC. ORDER_DATE\nD. PRODUCT_ID\nE. ORDER_ID\nF. SERIAL_NO\"",
        "answer": "E,F"
    },
    {
        "question": "\"检查EMPLOYEES表的描述：\n名称 Null? 类型\n-------------------------------------------------- ----------\nEMPLOYEE_ID NOT NULL NUMBER(4)\nEMPLOYEE_NAME NOT NULL VARCHAR2 (100)\nSALARY NOT NULL NUMBER(6,2)。\nDEPARTMENT_ID NOT NULL NUMBER(4)\n哪个语句会失败？\nA.  SELECT department_id, COUNT(*)\nFROM employees\nWHERE department_id <> 90\nHAVING COUNT(*) >= 3\nGROUP BY department_id;\nB.  SELECT department_id, COUNT (*)\nFROM employees\nWHERE department_id <> 90\nAND COUNT(*) >= 3\nGROUP BY department_id;\nC.  SELECT department_id, COUNT (*)\nFROM employees\nWHERE department_id < 90\nGROUP BY department_id\nHAVING COUNT(*) >= 3;\nD.  SELECT department_id, COUNT (*)\nFROM employees\nHAVING department_id < 90\nAND COUNT(*) >= 3\nGROUP BY department_id;\"",
        "answer": "B"
    }
]